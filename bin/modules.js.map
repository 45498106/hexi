{"version":3,"sources":["sound.js","scaleToWindow.js","bump.js","charm.js","tink.js","dust.js","spriteUtilities.js","gameUtilities.js","smoothie.js","tileUtilities.js"],"names":["global","exports","perf","fixSetTarget","param","setTargetAtTime","setTargetValueAtTime","window","hasOwnProperty","AudioContext","webkitAudioContext","prototype","createGain","createGainNode","createDelay","createDelayNode","createScriptProcessor","createJavaScriptNode","createPeriodicWave","createWaveTable","internal_createGain","node","gain","internal_createDelay","maxDelayTime","delayTime","internal_createBufferSource","createBufferSource","start","when","offset","duration","noteGrainOn","noteOn","internal_start","stop","noteOff","internal_stop","playbackRate","internal_createDynamicsCompressor","createDynamicsCompressor","threshold","knee","ratio","reduction","attack","release","internal_createBiquadFilter","createBiquadFilter","frequency","detune","Q","internal_createOscillator","createOscillator","setPeriodicWave","setWaveTable","OfflineAudioContext","webkitOfflineAudioContext","actx","sounds","toLoad","loaded","audioExtensions","whenLoaded","undefined","load","sources","console","log","self","length","forEach","source","extension","split","pop","indexOf","soundSprite","makeSound","loadHandler","bind","name","loadSound","xhr","o","volumeNode","createStereoPanner","panNode","createPanner","delayNode","feedbackNode","filterNode","convolverNode","createConvolver","soundNode","buffer","loop","playing","panValue","volumeValue","startTime","startOffset","echo","delayValue","feebackValue","filterValue","reverb","reverbImpulse","play","currentTime","value","connect","destination","pause","restart","playFrom","setEcho","feedbackValue","setReverb","decay","reverse","impulseResponse","fade","endValue","durationInSeconds","linearRampToValueAtTime","fadeIn","fadeOut","Object","defineProperties","volume","get","set","enumerable","configurable","pan","x","y","z","Math","abs","setPosition","decodeAudio","XMLHttpRequest","open","responseType","addEventListener","send","decodeAudioData","response","hasLoaded","error","Error","soundEffect","frequencyValue","type","wait","pitchBendAmount","randomValue","dissonance","timeout","oscillator","randomInt","min","max","floor","random","pitchBend","addEcho","addReverb","addDissonance","convolver","feedback","delay","filter","oscillatorNode","d1","d2","d1Volume","d2Volume","sampleRate","impulse","createBuffer","left","getChannelData","right","i","n","pow","keyboard","keyCode","key","code","isDown","isUp","press","downHandler","event","preventDefault","upHandler","scaleToWindow","canvas","backgroundColor","scaleX","scaleY","scale","center","innerWidth","offsetWidth","innerHeight","offsetHeight","style","transformOrigin","transform","offsetwidth","margin","marginLeft","marginRight","marginTop","marginBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","display","document","body","ua","navigator","userAgent","toLowerCase","_createClass","target","props","descriptor","writable","defineProperty","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","Bump","renderingEngine","arguments","PIXI","renderer","ParticleContainer","Sprite","addCollisionProperties","sprite","gx","getGlobalPosition","gy","centerX","width","centerY","height","halfWidth","halfHeight","xAnchorOffset","anchor","yAnchorOffset","circular","radius","_bumpPropertiesAdded","hitTestPoint","point","shape","top","bottom","vx","vy","magnitude","hit","_vx","_vy","_magnitude","sqrt","hitTestCircle","c1","c2","combinedRadii","circleCollision","bounce","overlap","dx","dy","s","quantumPadding","bounceOffSurface","movingCircleCollision","xSide","ySide","p1A","p1B","p2A","p2B","mass","vxHalf","vyHalf","lx","ly","dp1","dp2","dp3","dp4","multipleCircleCollision","arrayOfCircles","j","rectangleCollision","r1","r2","collision","combinedHalfWidths","combinedHalfHeights","overlapX","overlapY","hitTestRectangle","hitTestCircleRectangle","region","c1x","c1y","r1x","r1y","hitTestCirclePoint","diameter","circleRectangleCollision","circlePointCollision","p1","p2","contain","container","extra","parent","Set","add","size","outsideBounds","bounds","_getCenter","dimension","axis","a","b","react","aIsASprite","bIsASprite","Array","spriteVsArray","findCollisionType","circleVsCircle","circleVsRectangle","rectangleVsRectangle","_ref","_b","_a","_toConsumableArray","arr","isArray","arr2","from","Charm","_this","globalTweens","easingFormulas","linear","smoothstep","smoothstepSquared","smoothstepCubed","acceleration","accelerationCubed","deceleration","decelerationCubed","sine","sin","PI","sineSquared","sineCubed","inverseSine","inverseSineSquared","inverseSineCubed","spline","t","p0","p3","cubicBezier","c","d","t2","t3","_addScaleProperties","tweenProperty","property","startValue","totalFrames","_this2","yoyo","delayBeforeRepeat","typeArray","startMagnitude","parseInt","endMagnitude","JSON","parse","stringify","frameCounter","push","update","time","curvedTime","normalizedTime","end","onComplete","splice","then","makeTween","tweensToAdd","_this3","tweens","tweenPropertyArguments","newTween","apply","completionCounter","completed","tween","frames","alpha","pulse","minAlpha","slide","endX","endY","breathe","endScaleX","endScaleY","strobe","scaleFactor","wobble","scaleFactorX","scaleFactorY","xStartMagnitude","xEndMagnitude","yStartMagnitude","yEndMagnitude","friction","_this4","bounceX","bounceY","removeTween","followCurve","pointsArray","_this5","p","walkPath","originalPathArray","_this6","delayBetweenSections","pathArray","currentPoint","makePath","walkCurve","_this7","delayBeforeContinue","currentCurve","curveArray","Promise","resolve","reject","setTimeout","tweenObject","_this8","element","Tink","draggableSprites","pointers","buttons","TextureCache","utils","MovieClip","extras","Texture","makeDraggable","_len","sprites","_key","draggable","_localDraggableAllocation","spritesArray","makeUndraggable","_len2","_key2","makePointer","addGlobalPositionProperties","pointer","_scale","_x","_y","position","cursor","tapped","downTime","elapsedTime","tap","dragSprite","dragOffsetX","dragOffsetY","_visible","visible","moveHandler","pageX","offsetLeft","pageY","offsetTop","touchmoveHandler","targetTouches","Date","now","touchstartHandler","touchendHandler","hitTestSprite","distance","touchAction","updateDragAndDrop","children","some","makeInteractive","over","out","state","action","pressed","hoverOver","tinkType","enabled","updateButtons","gotoAndStop","button","fromFrames","fromImages","arrowControl","speed","upArrow","rightArrow","downArrow","leftArrow","Dust","Container","globalParticles","randomFloat","create","spriteFunction","numberOfParticles","gravity","randomSpacing","minAngle","maxAngle","minSize","maxSize","minSpeed","maxSpeed","minScaleSpeed","maxScaleSpeed","minAlphaSpeed","maxAlphaSpeed","minRotationSpeed","maxRotationSpeed","particles","angles","angle","spacing","makeParticle","particle","scaleSpeed","alphaSpeed","rotationSpeed","cos","addChild","updateParticle","rotation","removeChild","emitter","interval","particleFunction","timerInterval","setInterval","emitParticle","clearInterval","SpriteUtilities","Rectangle","BitmapText","TilingSprite","Graphics","Text","shakingSprites","shakingSprite","updateShake","tiling","texture","fromImage","addStatePlayer","numberOfFrames","startFrame","endFrame","show","frameNumber","reset","stopAnimation","currentFrame","playAnimation","sequenceArray","fps","frameRate","animating","advanceFrame","tilingSprite","tilePosition","tileScale","filmstrip","frameWidth","frameHeight","positions","textureWidth","textureHeight","columns","rows","frame","imageFrame","coordinates","baseTexture","textures","_textures","map","frameTexture","frameSeries","startNumber","endNumber","baseName","text","content","font","fillStyle","message","fill","_content","bitmapText","align","tint","rectangle","strokeStyle","lineWidth","_sprite","_width","_height","_fillStyle","color","_strokeStyle","_lineWidth","draw","clear","beginFill","lineStyle","drawRect","endFill","generateTexture","circle","_diameter","drawCircle","line","ax","ay","bx","by","_ax","_ay","_bx","_by","moveTo","lineTo","grid","cellWidth","cellHeight","centerCell","xOffset","yOffset","makeSprite","createGrid","shoot","shooter","bulletSpeed","bulletArray","bulletSprite","bullet","tempGx","tempGy","group","shake","angular","counter","numberOfShakes","startX","startY","startAngle","magnitudeUnit","angularShake","upAndDownShake","tiltAngle","batch","options","uvs","remove","colorToRGBA","cvs","ctx","createElement","getContext","fillRect","data","getImageData","byteToHex","num","toString","slice","colorToHex","rgba","hex","idx","join","isNaN","GameUtilities","s1","s2","followEase","follower","leader","followConstant","atan2","rotateAroundSprite","rotatingSprite","centerSprite","rotateAroundPoint","pointX","pointY","distanceX","distanceY","callBack","move","worldCamera","world","worldWidth","worldHeight","camera","rightInnerBoundary","leftInnerBoundary","topInnerBoundary","bottomInnerBoundary","follow","centerOver","Smoothie","engine","root","interpolate","renderFps","properties","tile","stage","_fps","_renderFps","paused","_startTime","_frameDuration","_lag","_lagOffset","_renderStartTime","_renderDuration","resume","gameLoop","timestamp","requestAnimationFrame","current","elapsed","capturePreviousSpriteProperties","render","setProperties","_previousX","_previousY","_previousRotation","_previousWidth","_previousHeight","_previousScaleX","_previousScaleY","_previousAlpha","_previousTilePositionX","_previousTilePositionY","_previousTileScaleX","_previousTileScaleY","child","lagOffset","interpolateSprite","_currentX","_currentY","_currentRotation","_currentWidth","_currentHeight","_currentScaleX","_currentScaleY","_currentAlpha","_currentTilePositionX","_currentTilePositionY","_currentTileScaleX","_currentTileScaleY","restoreSpriteProperties","TileUtilities","loader","resources","getIndex","tilewidth","tileheight","mapWidthInTiles","index","getTile","mapArray","gid","widthInTiles","centery","surroundingCells","getPoints","ca","collisionArea","topLeft","topRight","bottomLeft","bottomRight","hitTestTile","gidToCheck","pointsToCheck","checkPoints","collisionPoints","keys","every","updateMap","spritesToUpdate","newMapArray","makeTiledWorld","jsonTiledMap","tileset","tiledMap","heightInTiles","objects","tilesets","numberOfTilesetColumns","imagewidth","layers","tiledLayer","layerGroup","opacity","tileSprite","mapX","mapY","tilesetX","tilesetY","mapColumn","mapRow","tilesetColumn","tilesetRow","tileproperties","String","object","getObject","objectName","searchForObject","foundObject","getObjects","objectNames","foundObjects","byDepth","depth","cartX","cartY","hitTestIsoTile","cartTilewidth","cartTileheight","getIsoPoints","cartWidth","cartHeight","makeIsoPointer","column","row","isoRectangle","addIsoProperties","isoX","isoY","makeIsoTiledWorld","tiledMao","tileDepth"],"mappings":"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","file":"modules.js","sourcesContent":["\n/*\nSound.js\n===============\n\nA complete micro library of useful, modular functions that help you load, play, control\nand generate sound effects and music for games and interactive applications. All the\ncode targets the WebAudio API.\n*/\n\n\n/*\nFixing the WebAudio API\n--------------------------\n\nThe WebAudio API is so new that it's API is not consistently implemented properly across\nall modern browsers. Thankfully, Chris Wilson's Audio Context Monkey Patch script\nnormalizes the API for maximum compatibility.\n\nhttps://github.com/cwilso/AudioContext-MonkeyPatch/blob/gh-pages/AudioContextMonkeyPatch.js\n\nIt's included here.\nThank you, Chris!\n\n*/\n\n(function (global, exports, perf) {\n  'use strict';\n\n  function fixSetTarget(param) {\n    if (!param)\t// if NYI, just return\n      return;\n    if (!param.setTargetAtTime)\n      param.setTargetAtTime = param.setTargetValueAtTime;\n  }\n\n  if (window.hasOwnProperty('webkitAudioContext') &&\n      !window.hasOwnProperty('AudioContext')) {\n    window.AudioContext = webkitAudioContext;\n\n    if (!AudioContext.prototype.hasOwnProperty('createGain'))\n      AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n    if (!AudioContext.prototype.hasOwnProperty('createDelay'))\n      AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n    if (!AudioContext.prototype.hasOwnProperty('createScriptProcessor'))\n      AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;\n    if (!AudioContext.prototype.hasOwnProperty('createPeriodicWave'))\n      AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;\n\n\n    AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;\n    AudioContext.prototype.createGain = function() {\n      var node = this.internal_createGain();\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;\n    AudioContext.prototype.createDelay = function(maxDelayTime) {\n      var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();\n      fixSetTarget(node.delayTime);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;\n    AudioContext.prototype.createBufferSource = function() {\n      var node = this.internal_createBufferSource();\n      if (!node.start) {\n        node.start = function ( when, offset, duration ) {\n          if ( offset || duration )\n            this.noteGrainOn( when || 0, offset, duration );\n          else\n            this.noteOn( when || 0 );\n        };\n      } else {\n        node.internal_start = node.start;\n        node.start = function( when, offset, duration ) {\n          if( typeof duration !== 'undefined' )\n            node.internal_start( when || 0, offset, duration );\n          else\n            node.internal_start( when || 0, offset || 0 );\n        };\n      }\n      if (!node.stop) {\n        node.stop = function ( when ) {\n          this.noteOff( when || 0 );\n        };\n      } else {\n        node.internal_stop = node.stop;\n        node.stop = function( when ) {\n          node.internal_stop( when || 0 );\n        };\n      }\n      fixSetTarget(node.playbackRate);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;\n    AudioContext.prototype.createDynamicsCompressor = function() {\n      var node = this.internal_createDynamicsCompressor();\n      fixSetTarget(node.threshold);\n      fixSetTarget(node.knee);\n      fixSetTarget(node.ratio);\n      fixSetTarget(node.reduction);\n      fixSetTarget(node.attack);\n      fixSetTarget(node.release);\n      return node;\n    };\n\n    AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;\n    AudioContext.prototype.createBiquadFilter = function() {\n      var node = this.internal_createBiquadFilter();\n      fixSetTarget(node.frequency);\n      fixSetTarget(node.detune);\n      fixSetTarget(node.Q);\n      fixSetTarget(node.gain);\n      return node;\n    };\n\n    if (AudioContext.prototype.hasOwnProperty( 'createOscillator' )) {\n      AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;\n      AudioContext.prototype.createOscillator = function() {\n        var node = this.internal_createOscillator();\n        if (!node.start) {\n          node.start = function ( when ) {\n            this.noteOn( when || 0 );\n          };\n        } else {\n          node.internal_start = node.start;\n          node.start = function ( when ) {\n            node.internal_start( when || 0);\n          };\n        }\n        if (!node.stop) {\n          node.stop = function ( when ) {\n            this.noteOff( when || 0 );\n          };\n        } else {\n          node.internal_stop = node.stop;\n          node.stop = function( when ) {\n            node.internal_stop( when || 0 );\n          };\n        }\n        if (!node.setPeriodicWave)\n          node.setPeriodicWave = node.setWaveTable;\n        fixSetTarget(node.frequency);\n        fixSetTarget(node.detune);\n        return node;\n      };\n    }\n  }\n\n  if (window.hasOwnProperty('webkitOfflineAudioContext') &&\n      !window.hasOwnProperty('OfflineAudioContext')) {\n    window.OfflineAudioContext = webkitOfflineAudioContext;\n  }\n\n}(window));\n\n/*\nDefine the audio context\n------------------------\n\nAll this code uses a single `AudioContext` If you want to use any of these functions\nindependently of this file, make sure that have an `AudioContext` called `actx`. \n*/\nvar actx = new AudioContext();\n\n/*\nsounds\n------\n\n`sounds` is an object that you can use to store all your loaded sound fles. \nIt also has a helpful `load` method that manages asset loading. You can load sounds at\nany time during the game by using the `sounds.load` method. You don't have to use\nthe `sounds` object or its `load` method, but it's a really convenient way to \nwork with sound file assets.\n\nHere's how could use the `sound` object to load three sound files from a `sounds` folder and \ncall a `setup` method when all the files have finished loading:\n\n    sounds.load([\n      \"sounds/shoot.wav\", \n      \"sounds/music.wav\",\n      \"sounds/bounce.mp3\"\n    ]);\n    sounds.whenLoaded = setup;\n\nYou can now access these loaded sounds in your application code like this:\n\nvar shoot = sounds[\"sounds/shoot.wav\"],\n    music = sounds[\"sounds/music.wav\"],\n    bounce = sounds[\"sounds/bounce.mp3\"];\n\n*/\n\nvar sounds = {\n  //Properties to help track the assets being loaded.\n  toLoad: 0,\n  loaded: 0,\n\n  //File extensions for different types of sounds.\n  audioExtensions: [\"mp3\", \"ogg\", \"wav\", \"webm\"],\n\n  //The callback function that should run when all assets have loaded.\n  //Assign this when you load the fonts, like this: `assets.whenLoaded = makeSprites;`.\n  whenLoaded: undefined,\n\n  //The load method creates and loads all the assets. Use it like this:\n  //`assets.load([\"images/anyImage.png\", \"fonts/anyFont.otf\"]);`.\n\n  load: function(sources) {\n    console.log(\"Loading sounds..\");\n\n    //Get a reference to this asset object so we can\n    //refer to it in the `forEach` loop ahead.\n    var self = this;\n\n    //Find the number of files that need to be loaded.\n    self.toLoad = sources.length;\n    sources.forEach(function(source){\n\n      //Find the file extension of the asset.\n      var extension = source.split('.').pop();\n\n      //#### Sounds\n      //Load audio files that have file extensions that match\n      //the `audioExtensions` array.\n      if (self.audioExtensions.indexOf(extension) !== -1) {\n\n        //Create a sound sprite.\n        var soundSprite = makeSound(source, self.loadHandler.bind(self), true, false);\n\n        //Get the sound file name.\n        soundSprite.name = source;\n\n        //If you just want to extract the file name with the\n        //extension, you can do it like this:\n        //soundSprite.name = source.split(\"/\").pop();\n        //Assign the sound as a property of the assets object so\n        //we can access it like this: `assets[\"sounds/sound.mp3\"]`.\n        self[soundSprite.name] = soundSprite;\n      }\n\n      //Display a message if the file type isn't recognized.\n      else {\n        console.log(\"File type not recognized: \" + source);\n      }\n    });\n  },\n\n  //#### loadHandler\n  //The `loadHandler` will be called each time an asset finishes loading.\n  loadHandler: function () {\n    var self = this;\n    self.loaded += 1;\n    console.log(self.loaded);\n\n    //Check whether everything has loaded.\n    if (self.toLoad === self.loaded) {\n\n      //If it has, run the callback function that was assigned to the `whenLoaded` property\n      console.log(\"Sounds finished loading\");\n\n      //Reset `loaded` and `toLoaded` so we can load more assets\n      //later if we want to.\n      self.toLoad = 0;\n      self.loaded = 0;\n      self.whenLoaded();\n    }\n  }\n};\n\n/*\nmakeSound\n---------\n\n`makeSound` is the function you want to use to load and play sound files.\nIt creates and returns and WebAudio sound object with lots of useful methods you can\nuse to control the sound. \nYou can use it to load a sound like this:\n\n    var anySound = makeSound(\"sounds/anySound.mp3\", loadHandler);\n\n\nThe code above will load the sound and then call the `loadHandler`\nwhen the sound has finished loading. \n(However, it's more convenient to load the sound file using \nthe `sounds.load` method described above, so I don't recommend loading sounds\nlike this unless you need more low-level control.)\n\nAfter the sound has been loaded you can access and use it like this:\n\n    function loadHandler() {\n      anySound.loop = true;\n      anySound.pan = 0.8;\n      anySound.volume = 0.5;\n      anySound.play();\n      anySound.pause();\n      anySound.playFrom(second);\n      anySound.restart();\n      anySound.setReverb(2, 2, false);\n      anySound.setEcho(0.2, 0.2, 0);\n      anySound.playbackRate = 0.5;\n    }\n   \nFor advanced configurations, you can optionally supply `makeSound` with optional 3rd and \n4th arguments:\n\n   var anySound = makeSound(source, loadHandler, loadTheSound?, xhrObject);\n\n`loadTheSound?` is a Boolean (true/false) value that, if `false` prevents the sound file\nfrom being loaded. You would only want to set it to `false` like this if you were\nusing another file loading library to load the sound, and didn't want it to be loaded\ntwice.\n\n`xhrObject`, the optional 4th argument, is the XHR object that was used to load the sound. Again, you \nwould only supply this if you were using another file loading library to load the sound,\nand that library had generated its own XHR object. If you supply the `xhr` argument, `makeSound`\nwill skip the file loading step (because you've already done that), but still decode the audio buffer for you.\n(If you are loading the sound file using another file loading library, make sure that your sound\nfiles are loaded with the XHR `responseType = \"arraybuffer\"` option.)\n\nFor example, here's how you could use this advanced configuration to decode a sound that you've already loaded\nusing your own custom loading system:\n\n   var soundSprite = makeSound(source, decodeHandler.bind(this), false, xhr);\n\nWhen the file has finished being decoded, your custom `decodeHandler` will run, which tells you\nthat the file has finished decoding.\n\nIf you're creating more than one sound like this, use counter variables to track the number of sounds\nyou need to decode, and the number of sounds that have been decoded. When both sets of counters are the\nsame, you'll know that all your sound files have finished decoding and you can proceed with the rest\nof you application. (The [Hexi game engine](https://github.com/kittykatattack/hexi) uses `makeSound` in this way.)\n\n*/\n\nfunction makeSound(source, loadHandler, loadSound, xhr) {\n\n  //The sound object that this function returns.\n  var o = {};\n\n  //Set the default properties.\n  o.volumeNode = actx.createGain();\n\n  //Create the pan node using the efficient `createStereoPanner`\n  //method, if it's available.\n  if (!actx.createStereoPanner) {\n    o.panNode = actx.createPanner();\n  } else {\n    o.panNode = actx.createStereoPanner();\n  }\n  o.delayNode = actx.createDelay();\n  o.feedbackNode = actx.createGain();\n  o.filterNode = actx.createBiquadFilter();\n  o.convolverNode = actx.createConvolver();\n  o.soundNode = null;\n  o.buffer = null;\n  o.source = source;\n  o.loop = false;\n  o.playing = false;\n\n  //The function that should run when the sound is loaded.\n  o.loadHandler = undefined;\n\n  //Values for the `pan` and `volume` getters/setters.\n  o.panValue = 0;\n  o.volumeValue = 1;\n\n  //Values to help track and set the start and pause times.\n  o.startTime = 0;\n  o.startOffset = 0;\n\n  //Set the playback rate.\n  o.playbackRate = 1;\n\n  //Echo properties.\n  o.echo = false;\n  o.delayValue = 0.3;\n  o.feebackValue = 0.3;\n  o.filterValue = 0;\n\n  //Reverb properties\n  o.reverb = false;\n  o.reverbImpulse = null;\n  \n  //The sound object's methods.\n  o.play = function() {\n\n    //Set the start time (it will be `0` when the sound\n    //first starts.\n    o.startTime = actx.currentTime;\n\n    //Create a sound node.\n    o.soundNode = actx.createBufferSource();\n\n    //Set the sound node's buffer property to the loaded sound.\n    o.soundNode.buffer = o.buffer;\n\n    //Set the playback rate\n    o.soundNode.playbackRate.value = this.playbackRate;\n\n    //Connect the sound to the pan, connect the pan to the\n    //volume, and connect the volume to the destination.\n    o.soundNode.connect(o.volumeNode);\n\n    //If there's no reverb, bypass the convolverNode\n    if (o.reverb === false) {\n      o.volumeNode.connect(o.panNode);\n    } \n\n    //If there is reverb, connect the `convolverNode` and apply\n    //the impulse response\n    else {\n      o.volumeNode.connect(o.convolverNode);\n      o.convolverNode.connect(o.panNode);\n      o.convolverNode.buffer = o.reverbImpulse;\n    }\n    \n    //Connect the `panNode` to the destination to complete the chain.\n    o.panNode.connect(actx.destination);\n\n    //Add optional echo.\n    if (o.echo) {\n\n      //Set the values.\n      o.feedbackNode.gain.value = o.feebackValue;\n      o.delayNode.delayTime.value = o.delayValue;\n      o.filterNode.frequency.value = o.filterValue;\n\n      //Create the delay loop, with optional filtering.\n      o.delayNode.connect(o.feedbackNode);\n      if (o.filterValue > 0) {\n        o.feedbackNode.connect(o.filterNode);\n        o.filterNode.connect(o.delayNode);\n      } else {\n        o.feedbackNode.connect(o.delayNode);\n      }\n\n      //Capture the sound from the main node chain, send it to the\n      //delay loop, and send the final echo effect to the `panNode` which\n      //will then route it to the destination.\n      o.volumeNode.connect(o.delayNode);\n      o.delayNode.connect(o.panNode);\n    }\n\n    //Will the sound loop? This can be `true` or `false`.\n    o.soundNode.loop = o.loop;\n\n    //Finally, use the `start` method to play the sound.\n    //The start time will either be `0`,\n    //or a later time if the sound was paused.\n    o.soundNode.start(\n      0, o.startOffset % o.buffer.duration\n    );\n\n    //Set `playing` to `true` to help control the\n    //`pause` and `restart` methods.\n    o.playing = true;\n  };\n\n  o.pause = function() {\n    //Pause the sound if it's playing, and calculate the\n    //`startOffset` to save the current position.\n    if (o.playing) {\n      o.soundNode.stop(0);\n      o.startOffset += actx.currentTime - o.startTime;\n      o.playing = false;\n    }\n  };\n\n  o.restart = function() {\n    //Stop the sound if it's playing, reset the start and offset times,\n    //then call the `play` method again.\n    if (o.playing) {\n      o.soundNode.stop(0);\n    }\n    o.startOffset = 0;\n    o.play();\n  };\n\n  o.playFrom = function(value) {\n    if (o.playing) {\n      o.soundNode.stop(0);\n    }\n    o.startOffset = value;\n    o.play();\n  };\n\n  o.setEcho = function(delayValue, feedbackValue, filterValue) {\n    if (delayValue === undefined) delayValue = 0.3;\n    if (feedbackValue === undefined) feedbackValue = 0.3;\n    if (filterValue === undefined) filterValue = 0;\n    o.delayValue = delayValue;\n    o.feebackValue = feedbackValue;\n    o.filterValue = filterValue;\n    o.echo = true;\n  };\n\n  o.setReverb = function(duration, decay, reverse) {\n    if (duration === undefined) duration = 2;\n    if (decay === undefined) decay = 2;\n    if (reverse === undefined) reverse = false;\n    o.reverbImpulse = impulseResponse(duration, decay, reverse, actx);\n    o.reverb = true;\n  };\n\n  //A general purpose `fade` method for fading sounds in or out.\n  //The first argument is the volume that the sound should\n  //fade to, and the second value is the duration, in seconds,\n  //that the fade should last.\n  o.fade = function(endValue, durationInSeconds) {\n    if (o.playing) {\n      o.volumeNode.gain.linearRampToValueAtTime(\n        o.volumeNode.gain.value, actx.currentTime\n      );\n      o.volumeNode.gain.linearRampToValueAtTime(\n        endValue, actx.currentTime + durationInSeconds\n      );\n    }\n  };\n\n  //Fade a sound in, from an initial volume level of zero.\n  o.fadeIn = function(durationInSeconds) {\n    \n    //Set the volume to 0 so that you can fade\n    //in from silence\n    o.volumeNode.gain.value = 0;\n    o.fade(1, durationInSeconds);\n  \n  };\n\n  //Fade a sound out, from its current volume level to zero.\n  o.fadeOut = function(durationInSeconds) {\n    o.fade(0, durationInSeconds);\n  };\n  \n  //Volume and pan getters/setters.\n  Object.defineProperties(o, {\n    volume: {\n      get: function() {\n        return o.volumeValue;\n      },\n      set: function(value) {\n        o.volumeNode.gain.value = value;\n        o.volumeValue = value;\n      },\n      enumerable: true, configurable: true\n    },\n\n    //The pan node uses the high-efficiency stereo panner, if it's\n    //available. But, because this is a new addition to the \n    //WebAudio spec, it might not be available on all browsers.\n    //So the code checks for this and uses the older 3D panner\n    //if 2D isn't available.\n    pan: {\n      get: function() {\n        if (!actx.createStereoPanner) {\n          return o.panValue;\n        } else {\n          return o.panNode.pan.value;\n        }\n      },\n      set: function(value) {\n        if (!actx.createStereoPanner) {\n          //Panner objects accept x, y and z coordinates for 3D\n          //sound. However, because we're only doing 2D left/right\n          //panning we're only interested in the x coordinate,\n          //the first one. However, for a natural effect, the z\n          //value also has to be set proportionately.\n          var x = value,\n              y = 0,\n              z = 1 - Math.abs(x);\n          o.panNode.setPosition(x, y, z);\n          o.panValue = value;\n        } else {\n          o.panNode.pan.value = value;\n        }\n      },\n      enumerable: true, configurable: true\n    }\n  });\n\n  //Optionally Load and decode the sound.\n  if (loadSound) {\n    this.loadSound(o, source, loadHandler);\n  }\n\n  //Optionally, if you've loaded the sound using some other loader, just decode the sound\n  if (xhr) {\n    this.decodeAudio(o, xhr, loadHandler);\n  }\n\n  //Return the sound object.\n  return o;\n}\n\n//The `loadSound` function loads the sound file using XHR\nfunction loadSound(o, source, loadHandler) {\n  var xhr = new XMLHttpRequest();\n\n  //Use xhr to load the sound file.\n  xhr.open(\"GET\", source, true);\n  xhr.responseType = \"arraybuffer\";\n\n  //When the sound has finished loading, decode it using the\n  //`decodeAudio` function (which you'll see ahead)\n  xhr.addEventListener(\"load\", decodeAudio.bind(this, o, xhr, loadHandler)); \n\n  //Send the request to load the file.\n  xhr.send();\n}\n\n//The `decodeAudio` function decodes the audio file for you and \n//launches the `loadHandler` when it's done\nfunction decodeAudio(o, xhr, loadHandler) {\n\n  //Decode the sound and store a reference to the buffer.\n  actx.decodeAudioData(\n    xhr.response,\n    function(buffer) {\n      o.buffer = buffer;\n      o.hasLoaded = true;\n\n      //This next bit is optional, but important.\n      //If you have a load manager in your game, call it here so that\n      //the sound is registered as having loaded.\n      if (loadHandler) {\n        loadHandler();\n      }\n    },\n\n    //Throw an error if the sound can't be decoded.\n    function(error) {\n      throw new Error(\"Audio could not be decoded: \" + error);\n    }\n  );\n}\n\n\n/*\nsoundEffect\n-----------\n\nThe `soundEffect` function let's you generate your sounds and musical notes from scratch\n(Reverb effect requires the `impulseResponse` function that you'll see further ahead in this file)\n\nTo create a custom sound effect, define all the parameters that characterize your sound. Here's how to\ncreate a laser shooting sound:\n\n    soundEffect(\n      1046.5,           //frequency\n      0,                //attack\n      0.3,              //decay\n      \"sawtooth\",       //waveform\n      1,                //Volume\n      -0.8,             //pan\n      0,                //wait before playing\n      1200,             //pitch bend amount\n      false,            //reverse bend\n      0,                //random pitch range\n      25,               //dissonance\n      [0.2, 0.2, 2000], //echo: [delay, feedback, filter]\n      undefined         //reverb: [duration, decay, reverse?]\n      3                 //Maximum duration of sound, in seconds\n    );\n\nExperiment by changing these parameters to see what kinds of effects you can create, and build\nyour own library of custom sound effects for games.\n*/\n\nfunction soundEffect(\n  frequencyValue,      //The sound's fequency pitch in Hertz\n  attack,              //The time, in seconds, to fade the sound in\n  decay,               //The time, in seconds, to fade the sound out\n  type,                //waveform type: \"sine\", \"triangle\", \"square\", \"sawtooth\"\n  volumeValue,         //The sound's maximum volume\n  panValue,            //The speaker pan. left: -1, middle: 0, right: 1\n  wait,                //The time, in seconds, to wait before playing the sound\n  pitchBendAmount,     //The number of Hz in which to bend the sound's pitch down\n  reverse,             //If `reverse` is true the pitch will bend up\n  randomValue,         //A range, in Hz, within which to randomize the pitch\n  dissonance,          //A value in Hz. It creates 2 dissonant frequencies above and below the target pitch\n  echo,                //An array: [delayTimeInSeconds, feedbackTimeInSeconds, filterValueInHz]\n  reverb,              //An array: [durationInSeconds, decayRateInSeconds, reverse]\n  timeout              //A number, in seconds, which is the maximum duration for sound effects\n) {\n\n  //Set the default values\n  if (frequencyValue === undefined) frequencyValue = 200;\n  if (attack === undefined) attack = 0;\n  if (decay === undefined) decay = 1;\n  if (type === undefined) type = \"sine\";\n  if (volumeValue === undefined) volumeValue = 1;\n  if (panValue === undefined) panValue = 0;\n  if (wait === undefined) wait = 0;\n  if (pitchBendAmount === undefined) pitchBendAmount = 0;\n  if (reverse === undefined) reverse = false;\n  if (randomValue === undefined) randomValue = 0;\n  if (dissonance === undefined) dissonance = 0;\n  if (echo === undefined) echo = undefined;\n  if (reverb === undefined) reverb = undefined;\n  if (timeout === undefined) timeout = undefined;\n\n  //Create an oscillator, gain and pan nodes, and connect them\n  //together to the destination\n  var oscillator, volume, pan;\n  oscillator = actx.createOscillator();\n  volume = actx.createGain();\n  if (!actx.createStereoPanner) {\n    pan = actx.createPanner();\n  } else {\n    pan = actx.createStereoPanner();\n  }\n  oscillator.connect(volume);\n  volume.connect(pan);\n  pan.connect(actx.destination);\n\n  //Set the supplied values\n  volume.gain.value = volumeValue;\n  if (!actx.createStereoPanner) {\n    pan.setPosition(panValue, 0, 1 - Math.abs(panValue));\n  } else {\n    pan.pan.value = panValue; \n  }\n  oscillator.type = type;\n\n  //Optionally randomize the pitch. If the `randomValue` is greater\n  //than zero, a random pitch is selected that's within the range\n  //specified by `frequencyValue`. The random pitch will be either\n  //above or below the target frequency.\n  var frequency;\n  var randomInt = function(min, max){\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  };\n  if (randomValue > 0) {\n    frequency = randomInt(\n      frequencyValue - randomValue / 2,\n      frequencyValue + randomValue / 2\n    );\n  } else {\n    frequency = frequencyValue;\n  }\n  oscillator.frequency.value = frequency;\n\n  //Apply effects\n  if (attack > 0) fadeIn(volume);\n  fadeOut(volume);\n  if (pitchBendAmount > 0) pitchBend(oscillator);\n  if (echo) addEcho(volume);\n  if (reverb) addReverb(volume);\n  if (dissonance > 0) addDissonance();\n\n  //Play the sound\n  play(oscillator);\n\n  //The helper functions:\n  \n  function addReverb(volumeNode) {\n    var convolver = actx.createConvolver();\n    convolver.buffer = impulseResponse(reverb[0], reverb[1], reverb[2], actx);\n    volumeNode.connect(convolver);\n    convolver.connect(pan);\n  }\n\n  function addEcho(volumeNode) {\n\n    //Create the nodes\n    var feedback = actx.createGain(),\n        delay = actx.createDelay(),\n        filter = actx.createBiquadFilter();\n\n    //Set their values (delay time, feedback time and filter frequency)\n    delay.delayTime.value = echo[0];\n    feedback.gain.value = echo[1];\n    if (echo[2]) filter.frequency.value = echo[2];\n\n    //Create the delay feedback loop, with\n    //optional filtering\n    delay.connect(feedback);\n    if (echo[2]) {\n      feedback.connect(filter);\n      filter.connect(delay);\n    } else {\n      feedback.connect(delay);\n    }\n\n    //Connect the delay loop to the oscillator's volume\n    //node, and then to the destination\n    volumeNode.connect(delay);\n\n    //Connect the delay loop to the main sound chain's\n    //pan node, so that the echo effect is directed to\n    //the correct speaker\n    delay.connect(pan);\n  }\n\n  //The `fadeIn` function\n  function fadeIn(volumeNode) {\n\n    //Set the volume to 0 so that you can fade\n    //in from silence\n    volumeNode.gain.value = 0;\n\n    volumeNode.gain.linearRampToValueAtTime(\n      0, actx.currentTime + wait\n    );\n    volumeNode.gain.linearRampToValueAtTime(\n      volumeValue, actx.currentTime + wait + attack\n    );\n  }\n\n  //The `fadeOut` function\n  function fadeOut(volumeNode) {\n    volumeNode.gain.linearRampToValueAtTime(\n      volumeValue, actx.currentTime + attack + wait\n    );\n    volumeNode.gain.linearRampToValueAtTime(\n      0, actx.currentTime + wait + attack + decay\n    );\n  }\n\n  //The `pitchBend` function\n  function pitchBend(oscillatorNode) {\n    //If `reverse` is true, make the note drop in frequency. Useful for\n    //shooting sounds\n\n    //Get the frequency of the current oscillator\n    var frequency = oscillatorNode.frequency.value;\n\n    //If `reverse` is true, make the sound drop in pitch\n    if (!reverse) {\n      oscillatorNode.frequency.linearRampToValueAtTime(\n        frequency, \n        actx.currentTime + wait\n      );\n      oscillatorNode.frequency.linearRampToValueAtTime(\n        frequency - pitchBendAmount, \n        actx.currentTime + wait + attack + decay\n      );\n    }\n\n    //If `reverse` is false, make the note rise in pitch. Useful for\n    //jumping sounds\n    else {\n      oscillatorNode.frequency.linearRampToValueAtTime(\n        frequency, \n        actx.currentTime + wait\n      );\n      oscillatorNode.frequency.linearRampToValueAtTime(\n        frequency + pitchBendAmount, \n        actx.currentTime + wait + attack + decay\n      );\n    }\n  }\n\n  //The `addDissonance` function\n  function addDissonance() {\n\n    //Create two more oscillators and gain nodes\n    var d1 = actx.createOscillator(),\n        d2 = actx.createOscillator(),\n        d1Volume = actx.createGain(),\n        d2Volume = actx.createGain();\n\n    //Set the volume to the `volumeValue`\n    d1Volume.gain.value = volumeValue;\n    d2Volume.gain.value = volumeValue;\n\n    //Connect the oscillators to the gain and destination nodes\n    d1.connect(d1Volume);\n    d1Volume.connect(actx.destination);\n    d2.connect(d2Volume);\n    d2Volume.connect(actx.destination);\n\n    //Set the waveform to \"sawtooth\" for a harsh effect\n    d1.type = \"sawtooth\";\n    d2.type = \"sawtooth\";\n\n    //Make the two oscillators play at frequencies above and\n    //below the main sound's frequency. Use whatever value was\n    //supplied by the `dissonance` argument\n    d1.frequency.value = frequency + dissonance;\n    d2.frequency.value = frequency - dissonance;\n\n    //Fade in/out, pitch bend and play the oscillators\n    //to match the main sound\n    if (attack > 0) {\n      fadeIn(d1Volume);\n      fadeIn(d2Volume);\n    }\n    if (decay > 0) {\n      fadeOut(d1Volume);\n      fadeOut(d2Volume);\n    }\n    if (pitchBendAmount > 0) {\n      pitchBend(d1);\n      pitchBend(d2);\n    }\n    if (echo) {\n      addEcho(d1Volume);\n      addEcho(d2Volume);\n    }\n    if (reverb) {\n      addReverb(d1Volume);\n      addReverb(d2Volume);\n    }\n    play(d1);\n    play(d2);\n  }\n\n  //The `play` function\n  function play(node) {\n    node.start(actx.currentTime + wait);\n\n    //Oscillators have to be stopped otherwise they accumulate in \n    //memory and tax the CPU. They'll be stopped after a default\n    //timeout of 2 seconds, which should be enough for most sound \n    //effects. Override this in the `soundEffect` parameters if you\n    //need a longer sound\n    node.stop(actx.currentTime + wait + 2);\n  }\n}\n\n/*\nimpulseResponse\n---------------\n\nThe `makeSound` and `soundEffect` functions uses `impulseResponse`  to help create an optional reverb effect.  \nIt simulates a model of sound reverberation in an acoustic space which \na convolver node can blend with the source sound. Make sure to include this function along with `makeSound`\nand `soundEffect` if you need to use the reverb feature.\n*/\n\nfunction impulseResponse(duration, decay, reverse, actx) {\n\n  //The length of the buffer.\n  var length = actx.sampleRate * duration;\n\n  //Create an audio buffer (an empty sound container) to store the reverb effect.\n  var impulse = actx.createBuffer(2, length, actx.sampleRate);\n\n  //Use `getChannelData` to initialize empty arrays to store sound data for\n  //the left and right channels.\n  var left = impulse.getChannelData(0),\n      right = impulse.getChannelData(1);\n\n  //Loop through each sample-frame and fill the channel\n  //data with random noise.\n  for (var i = 0; i < length; i++){\n\n    //Apply the reverse effect, if `reverse` is `true`.\n    var n;\n    if (reverse) {\n      n = length - i;\n    } else {\n      n = i;\n    }\n\n    //Fill the left and right channels with random white noise which\n    //decays exponentially.\n    left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n    right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n  }\n\n  //Return the `impulse`.\n  return impulse;\n}\n\n\n/*\nkeyboard\n--------\n\nThis isn't really necessary - I just included it for fun to help with the \nexamples in the `index.html` files.\nThe `keyboard` helper function creates `key` objects\nthat listen for keyboard events. Create a new key object like\nthis:\n\n    var keyObject = g.keyboard(asciiKeyCodeNumber);\n\nThen assign `press` and `release` methods like this:\n\n    keyObject.press = function() {\n      //key object pressed\n    };\n    keyObject.release = function() {\n      //key object released\n    };\n\nKeyboard objects also have `isDown` and `isUp` Booleans that you can check.\nThis is so much easier than having to write out tedious keyboard even capture \ncode from scratch.\n\nLike I said, the `keyboard` function has nothing to do with generating sounds,\nso just delete it if you don't want it!\n*/\n\nfunction keyboard(keyCode) {\n  var key = {};\n  key.code = keyCode;\n  key.isDown = false;\n  key.isUp = true;\n  key.press = undefined;\n  key.release = undefined;\n  //The `downHandler`\n  key.downHandler = function(event) {\n    if (event.keyCode === key.code) {\n      if (key.isUp && key.press) key.press();\n      key.isDown = true;\n      key.isUp = false;\n    }\n    event.preventDefault();\n  };\n\n  //The `upHandler`\n  key.upHandler = function(event) {\n    if (event.keyCode === key.code) {\n      if (key.isDown && key.release) key.release();\n      key.isDown = false;\n      key.isUp = true;\n    }\n    event.preventDefault();\n  };\n\n  //Attach event listeners\n  window.addEventListener(\n    \"keydown\", key.downHandler.bind(key), false\n  );\n  window.addEventListener(\n    \"keyup\", key.upHandler.bind(key), false\n  );\n  return key;\n}\n\n","\nfunction scaleToWindow(canvas, backgroundColor) {\n\n  backgroundColor = backgroundColor || \"#2C3539\";\n  var scaleX, scaleY, scale, center;\n  \n  //1. Scale the canvas to the correct size\n  //Figure out the scale amount on each axis\n  scaleX = window.innerWidth / canvas.offsetWidth;\n  scaleY = window.innerHeight / canvas.offsetHeight;\n\n  //Scale the canvas based on whichever value is less: `scaleX` or `scaleY`\n  scale = Math.min(scaleX, scaleY);\n  canvas.style.transformOrigin = \"0 0\";\n  canvas.style.transform = \"scale(\" + scale + \")\";\n  console.log(scaleX)\n\n  //2. Center the canvas.\n  //Decide whether to center the canvas vertically or horizontally.\n  //Wide canvases should be centered vertically, and \n  //square or tall canvases should be centered horizontally\n  if (canvas.offsetwidth > canvas.offsetHeight) {\n    if (canvas.offsetWidth * scale < window.innerWidth) {\n      center = \"horizontally\";\n    } else { \n      center = \"vertically\";\n    }\n  } else {\n    if (canvas.offsetHeight * scale < window.innerHeight) {\n      center = \"vertically\";\n    } else { \n      center = \"horizontally\";\n    }\n  }\n  \n  //Center horizontally (for square or tall canvases)\n  var margin;\n  if (center === \"horizontally\") {\n    margin = (window.innerWidth - canvas.offsetWidth * scale) / 2;\n    canvas.style.marginLeft = margin + \"px\";\n    canvas.style.marginRight = margin + \"px\";\n  }\n\n  //Center vertically (for wide canvases) \n  if (center === \"vertically\") {\n    margin = (window.innerHeight - canvas.offsetHeight * scale) / 2;\n    canvas.style.marginTop = margin + \"px\";\n    canvas.style.marginBottom = margin + \"px\";\n  }\n\n  //3. Remove any padding from the canvas  and body and set the canvas\n  //display style to \"block\"\n  canvas.style.paddingLeft = 0;\n  canvas.style.paddingRight = 0;\n  canvas.style.paddingTop = 0;\n  canvas.style.paddingBottom = 0;\n  canvas.style.display = \"block\";\n  \n  //4. Set the color of the HTML body background\n  document.body.style.backgroundColor = backgroundColor;\n  \n  //Fix some quirkiness in scaling for Safari\n  var ua = navigator.userAgent.toLowerCase(); \n  if (ua.indexOf(\"safari\") != -1) { \n    if (ua.indexOf(\"chrome\") > -1) {\n      // Chrome\n    } else {\n      // Safari\n      //canvas.style.maxHeight = \"100%\";\n      //canvas.style.minHeight = \"100%\";\n    }\n  }\n\n  //5. Return the `scale` value. This is important, because you'll nee this value \n  //for correct hit testing between the pointer and sprites\n  return scale;\n}\n","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bump = (function () {\n  function Bump() {\n    var renderingEngine = arguments.length <= 0 || arguments[0] === undefined ? PIXI : arguments[0];\n\n    _classCallCheck(this, Bump);\n\n    if (renderingEngine === undefined) throw new Error(\"Please assign a rendering engine in the constructor before using bump.js\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderer = \"pixi\";\n    }\n  }\n\n  //`addCollisionProperties` adds extra properties to sprites to help\n  //simplify the collision code. It won't add these properties if they\n  //already exist on the sprite. After these properties have been\n  //added, this methods adds a Boolean property to the sprite called `_bumpPropertiesAdded`\n  //and sets it to `true` to flag that the sprite has these\n  //new properties\n\n  _createClass(Bump, [{\n    key: \"addCollisionProperties\",\n    value: function addCollisionProperties(sprite) {\n\n      //Add properties to Pixi sprites\n      if (this.renderer === \"pixi\") {\n\n        //gx\n        if (sprite.gx === undefined) {\n          Object.defineProperty(sprite, \"gx\", {\n            get: function get() {\n              return sprite.getGlobalPosition().x;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //gy\n        if (sprite.gy === undefined) {\n          Object.defineProperty(sprite, \"gy\", {\n            get: function get() {\n              return sprite.getGlobalPosition().y;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //centerX\n        if (sprite.centerX === undefined) {\n          Object.defineProperty(sprite, \"centerX\", {\n            get: function get() {\n              return sprite.x + sprite.width / 2;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //centerY\n        if (sprite.centerY === undefined) {\n          Object.defineProperty(sprite, \"centerY\", {\n            get: function get() {\n              return sprite.y + sprite.height / 2;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //halfWidth\n        if (sprite.halfWidth === undefined) {\n          Object.defineProperty(sprite, \"halfWidth\", {\n            get: function get() {\n              return sprite.width / 2;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //halfHeight\n        if (sprite.halfHeight === undefined) {\n          Object.defineProperty(sprite, \"halfHeight\", {\n            get: function get() {\n              return sprite.height / 2;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //xAnchorOffset\n        if (sprite.xAnchorOffset === undefined) {\n          Object.defineProperty(sprite, \"xAnchorOffset\", {\n            get: function get() {\n              if (sprite.anchor !== undefined) {\n                return sprite.height * sprite.anchor.x;\n              } else {\n                return 0;\n              }\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //yAnchorOffset\n        if (sprite.yAnchorOffset === undefined) {\n          Object.defineProperty(sprite, \"yAnchorOffset\", {\n            get: function get() {\n              if (sprite.anchor !== undefined) {\n                return sprite.width * sprite.anchor.y;\n              } else {\n                return 0;\n              }\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        if (sprite.circular && sprite.radius === undefined) {\n          Object.defineProperty(sprite, \"radius\", {\n            get: function get() {\n              return sprite.width / 2;\n            },\n\n            enumerable: true, configurable: true\n          });\n        }\n\n        //Earlier code - not needed now.\n        /*\n        Object.defineProperties(sprite, {\n          \"gx\": {\n            get(){return sprite.getGlobalPosition().x},\n            enumerable: true, configurable: true\n          },\n          \"gy\": {\n            get(){return sprite.getGlobalPosition().y},\n            enumerable: true, configurable: true\n          },\n          \"centerX\": {\n            get(){return sprite.x + sprite.width / 2},\n            enumerable: true, configurable: true\n          },\n          \"centerY\": {\n            get(){return sprite.y + sprite.height / 2},\n            enumerable: true, configurable: true\n          },\n          \"halfWidth\": {\n            get(){return sprite.width / 2},\n            enumerable: true, configurable: true\n          },\n          \"halfHeight\": {\n            get(){return sprite.height / 2},\n            enumerable: true, configurable: true\n          },\n          \"xAnchorOffset\": {\n            get(){\n              if (sprite.anchor !== undefined) {\n                return sprite.height * sprite.anchor.x;\n              } else {\n                return 0;\n              }\n            },\n            enumerable: true, configurable: true\n          },\n          \"yAnchorOffset\": {\n            get(){\n              if (sprite.anchor !== undefined) {\n                return sprite.width * sprite.anchor.y;\n              } else {\n                return 0;\n              }\n            },\n            enumerable: true, configurable: true\n          }\n        });\n        */\n      }\n\n      //Add a Boolean `_bumpPropertiesAdded` property to the sprite to flag it\n      //as having these new properties\n      sprite._bumpPropertiesAdded = true;\n    }\n\n    /*\n    hitTestPoint\n    ------------\n     Use it to find out if a point is touching a circlular or rectangular sprite.\n    Parameters: \n    a. An object with `x` and `y` properties.\n    b. A sprite object with `x`, `y`, `centerX` and `centerY` properties.\n    If the sprite has a `radius` property, the function will interpret\n    the shape as a circle.\n    */\n\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(point, sprite) {\n\n      //Add collision properties\n      if (!sprite._bumpPropertiesAdded) this.addCollisionProperties(sprite);\n\n      var shape = undefined,\n          left = undefined,\n          right = undefined,\n          top = undefined,\n          bottom = undefined,\n          vx = undefined,\n          vy = undefined,\n          magnitude = undefined,\n          hit = undefined;\n\n      //Find out if the sprite is rectangular or circular depending\n      //on whether it has a `radius` property\n      if (sprite.radius) {\n        shape = \"circle\";\n      } else {\n        shape = \"rectangle\";\n      }\n\n      //Rectangle\n      if (shape === \"rectangle\") {\n\n        //Get the position of the sprite's edges\n        left = sprite.x - sprite.xAnchorOffset;\n        right = sprite.x + sprite.width - sprite.xAnchorOffset;\n        top = sprite.y - sprite.yAnchorOffset;\n        bottom = sprite.y + sprite.height - sprite.yAnchorOffset;\n\n        //Find out if the point is intersecting the rectangle\n        hit = point.x > left && point.x < right && point.y > top && point.y < bottom;\n      }\n\n      //Circle\n      if (shape === \"circle\") {\n\n        //Find the distance between the point and the\n        //center of the circle\n        var _vx = point.x - sprite.x - sprite.width / 2 + sprite.xAnchorOffset,\n            _vy = point.y - sprite.y - sprite.height / 2 + sprite.yAnchorOffset,\n            _magnitude = Math.sqrt(_vx * _vx + _vy * _vy);\n\n        //The point is intersecting the circle if the magnitude\n        //(distance) is less than the circle's radius\n        hit = _magnitude < sprite.radius;\n      }\n\n      //`hit` will be either `true` or `false`\n      return hit;\n    }\n\n    /*\n    hitTestCircle\n    -------------\n     Use it to find out if two circular sprites are touching.\n    Parameters: \n    a. A sprite object with `centerX`, `centerY` and `radius` properties.\n    b. A sprite object with `centerX`, `centerY` and `radius`.\n    */\n\n  }, {\n    key: \"hitTestCircle\",\n    value: function hitTestCircle(c1, c2) {\n      var global = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Add collision properties\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n      if (!c2._bumpPropertiesAdded) this.addCollisionProperties(c2);\n\n      var vx = undefined,\n          vy = undefined,\n          magnitude = undefined,\n          combinedRadii = undefined,\n          hit = undefined;\n\n      //Calculate the vector between the circles’ center points\n      if (global) {\n        //Use global coordinates\n        vx = c2.gx + c2.width / 2 - c2.xAnchorOffset - (c1.gx + c1.width / 2 - c1.xAnchorOffset);\n        vy = c2.gy + c2.width / 2 - c2.yAnchorOffset - (c1.gy + c1.width / 2 - c1.yAnchorOffset);\n      } else {\n        //Use local coordinates\n        vx = c2.x + c2.width / 2 - c2.xAnchorOffset - (c1.x + c1.width / 2 - c1.xAnchorOffset);\n        vy = c2.y + c2.width / 2 - c2.yAnchorOffset - (c1.y + c1.width / 2 - c1.yAnchorOffset);\n      }\n\n      //Find the distance between the circles by calculating\n      //the vector's magnitude (how long the vector is)\n      magnitude = Math.sqrt(vx * vx + vy * vy);\n\n      //Add together the circles' total radii\n      combinedRadii = c1.radius + c2.radius;\n\n      //Set `hit` to `true` if the distance between the circles is\n      //less than their `combinedRadii`\n      hit = magnitude < combinedRadii;\n\n      //`hit` will be either `true` or `false`\n      return hit;\n    }\n\n    /*\n    circleCollision\n    ---------------\n     Use it to prevent a moving circular sprite from overlapping and optionally\n    bouncing off a non-moving circular sprite.\n    Parameters: \n    a. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n    b. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n    c. Optional: true or false to indicate whether or not the first sprite\n    should bounce off the second sprite.\n    The sprites can contain an optional mass property that should be greater than 1.\n     */\n\n  }, {\n    key: \"circleCollision\",\n    value: function circleCollision(c1, c2) {\n      var bounce = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var global = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n      //Add collision properties\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n      if (!c2._bumpPropertiesAdded) this.addCollisionProperties(c2);\n\n      var magnitude = undefined,\n          combinedRadii = undefined,\n          overlap = undefined,\n          vx = undefined,\n          vy = undefined,\n          dx = undefined,\n          dy = undefined,\n          s = {},\n          hit = false;\n\n      //Calculate the vector between the circles’ center points\n\n      if (global) {\n        //Use global coordinates\n        vx = c2.gx + c2.width / 2 - c2.xAnchorOffset - (c1.gx + c1.width / 2 - c1.xAnchorOffset);\n        vy = c2.gy + c2.width / 2 - c2.yAnchorOffset - (c1.gy + c1.width / 2 - c1.yAnchorOffset);\n      } else {\n        //Use local coordinates\n        vx = c2.x + c2.width / 2 - c2.xAnchorOffset - (c1.x + c1.width / 2 - c1.xAnchorOffset);\n        vy = c2.y + c2.width / 2 - c2.yAnchorOffset - (c1.y + c1.width / 2 - c1.yAnchorOffset);\n      }\n\n      //Find the distance between the circles by calculating\n      //the vector's magnitude (how long the vector is)\n      magnitude = Math.sqrt(vx * vx + vy * vy);\n\n      //Add together the circles' combined half-widths\n      combinedRadii = c1.radius + c2.radius;\n\n      //Figure out if there's a collision\n      if (magnitude < combinedRadii) {\n\n        //Yes, a collision is happening\n        hit = true;\n\n        //Find the amount of overlap between the circles\n        overlap = combinedRadii - magnitude;\n\n        //Add some \"quantum padding\". This adds a tiny amount of space\n        //between the circles to reduce their surface tension and make\n        //them more slippery. \"0.3\" is a good place to start but you might\n        //need to modify this slightly depending on the exact behaviour\n        //you want. Too little and the balls will feel sticky, too much\n        //and they could start to jitter if they're jammed together\n        var quantumPadding = 0.3;\n        overlap += quantumPadding;\n\n        //Normalize the vector\n        //These numbers tell us the direction of the collision\n        dx = vx / magnitude;\n        dy = vy / magnitude;\n\n        //Move circle 1 out of the collision by multiplying\n        //the overlap with the normalized vector and subtract it from\n        //circle 1's position\n        c1.x -= overlap * dx;\n        c1.y -= overlap * dy;\n\n        //Bounce\n        if (bounce) {\n          //Create a collision vector object, `s` to represent the bounce \"surface\".\n          //Find the bounce surface's x and y properties\n          //(This represents the normal of the distance vector between the circles)\n          s.x = vy;\n          s.y = -vx;\n\n          //Bounce c1 off the surface\n          this.bounceOffSurface(c1, s);\n        }\n      }\n      return hit;\n    }\n\n    /*\n    movingCircleCollision\n    ---------------------\n     Use it to make two moving circles bounce off each other.\n    Parameters: \n    a. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n    b. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\n    The sprites can contain an optional mass property that should be greater than 1.\n     */\n\n  }, {\n    key: \"movingCircleCollision\",\n    value: function movingCircleCollision(c1, c2) {\n      var global = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Add collision properties\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n      if (!c2._bumpPropertiesAdded) this.addCollisionProperties(c2);\n\n      var combinedRadii = undefined,\n          overlap = undefined,\n          xSide = undefined,\n          ySide = undefined,\n\n      //`s` refers to the distance vector between the circles\n      s = {},\n          p1A = {},\n          p1B = {},\n          p2A = {},\n          p2B = {},\n          hit = false;\n\n      //Apply mass, if the circles have mass properties\n      c1.mass = c1.mass || 1;\n      c2.mass = c2.mass || 1;\n\n      //Calculate the vector between the circles’ center points\n      if (global) {\n\n        //Use global coordinates\n        s.vx = c2.gx + c2.radius - c2.xAnchorOffset - (c1.gx + c1.radius - c1.xAnchorOffset);\n        s.vy = c2.gy + c2.radius - c2.yAnchorOffset - (c1.gy + c1.radius - c1.yAnchorOffset);\n      } else {\n\n        //Use local coordinates\n        s.vx = c2.x + c2.radius - c2.xAnchorOffset - (c1.x + c1.radius - c1.xAnchorOffset);\n        s.vy = c2.y + c2.radius - c2.yAnchorOffset - (c1.y + c1.radius - c1.yAnchorOffset);\n      }\n\n      //Find the distance between the circles by calculating\n      //the vector's magnitude (how long the vector is)\n      s.magnitude = Math.sqrt(s.vx * s.vx + s.vy * s.vy);\n\n      //Add together the circles' combined half-widths\n      combinedRadii = c1.radius + c2.radius;\n\n      //Figure out if there's a collision\n      if (s.magnitude < combinedRadii) {\n\n        //Yes, a collision is happening\n        hit = true;\n\n        //Find the amount of overlap between the circles\n        overlap = combinedRadii - s.magnitude;\n\n        //Add some \"quantum padding\" to the overlap\n        overlap += 0.3;\n\n        //Normalize the vector.\n        //These numbers tell us the direction of the collision\n        s.dx = s.vx / s.magnitude;\n        s.dy = s.vy / s.magnitude;\n\n        //Find the collision vector.\n        //Divide it in half to share between the circles, and make it absolute\n        s.vxHalf = Math.abs(s.dx * overlap / 2);\n        s.vyHalf = Math.abs(s.dy * overlap / 2);\n\n        //Find the side that the collision is occurring on\n        c1.x > c2.x ? xSide = 1 : xSide = -1;\n        c1.y > c2.y ? ySide = 1 : ySide = -1;\n\n        //Move c1 out of the collision by multiplying\n        //the overlap with the normalized vector and adding it to\n        //the circles' positions\n        c1.x = c1.x + s.vxHalf * xSide;\n        c1.y = c1.y + s.vyHalf * ySide;\n\n        //Move c2 out of the collision\n        c2.x = c2.x + s.vxHalf * -xSide;\n        c2.y = c2.y + s.vyHalf * -ySide;\n\n        //1. Calculate the collision surface's properties\n\n        //Find the surface vector's left normal\n        s.lx = s.vy;\n        s.ly = -s.vx;\n\n        //2. Bounce c1 off the surface (s)\n\n        //Find the dot product between c1 and the surface\n        var dp1 = c1.vx * s.dx + c1.vy * s.dy;\n\n        //Project c1's velocity onto the collision surface\n        p1A.x = dp1 * s.dx;\n        p1A.y = dp1 * s.dy;\n\n        //Find the dot product of c1 and the surface's left normal (s.lx and s.ly)\n        var dp2 = c1.vx * (s.lx / s.magnitude) + c1.vy * (s.ly / s.magnitude);\n\n        //Project the c1's velocity onto the surface's left normal\n        p1B.x = dp2 * (s.lx / s.magnitude);\n        p1B.y = dp2 * (s.ly / s.magnitude);\n\n        //3. Bounce c2 off the surface (s)\n\n        //Find the dot product between c2 and the surface\n        var dp3 = c2.vx * s.dx + c2.vy * s.dy;\n\n        //Project c2's velocity onto the collision surface\n        p2A.x = dp3 * s.dx;\n        p2A.y = dp3 * s.dy;\n\n        //Find the dot product of c2 and the surface's left normal (s.lx and s.ly)\n        var dp4 = c2.vx * (s.lx / s.magnitude) + c2.vy * (s.ly / s.magnitude);\n\n        //Project c2's velocity onto the surface's left normal\n        p2B.x = dp4 * (s.lx / s.magnitude);\n        p2B.y = dp4 * (s.ly / s.magnitude);\n\n        //4. Calculate the bounce vectors\n\n        //Bounce c1\n        //using p1B and p2A\n        c1.bounce = {};\n        c1.bounce.x = p1B.x + p2A.x;\n        c1.bounce.y = p1B.y + p2A.y;\n\n        //Bounce c2\n        //using p1A and p2B\n        c2.bounce = {};\n        c2.bounce.x = p1A.x + p2B.x;\n        c2.bounce.y = p1A.y + p2B.y;\n\n        //Add the bounce vector to the circles' velocity\n        //and add mass if the circle has a mass property\n        c1.vx = c1.bounce.x / c1.mass;\n        c1.vy = c1.bounce.y / c1.mass;\n        c2.vx = c2.bounce.x / c2.mass;\n        c2.vy = c2.bounce.y / c2.mass;\n      }\n      return hit;\n    }\n    /*\n    multipleCircleCollision\n    -----------------------\n     Checks all the circles in an array for a collision against\n    all the other circles in an array, using `movingCircleCollision` (above)\n    */\n\n  }, {\n    key: \"multipleCircleCollision\",\n    value: function multipleCircleCollision(arrayOfCircles) {\n      var global = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      for (var i = 0; i < arrayOfCircles.length; i++) {\n\n        //The first circle to use in the collision check\n        var c1 = arrayOfCircles[i];\n        for (var j = i + 1; j < arrayOfCircles.length; j++) {\n\n          //The second circle to use in the collision check\n          var c2 = arrayOfCircles[j];\n\n          //Check for a collision and bounce the circles apart if\n          //they collide. Use an optional `mass` property on the sprite\n          //to affect the bounciness of each marble\n          this.movingCircleCollision(c1, c2, global);\n        }\n      }\n    }\n\n    /*\n    rectangleCollision\n    ------------------\n     Use it to prevent two rectangular sprites from overlapping. \n    Optionally, make the first rectangle bounce off the second rectangle.\n    Parameters: \n    a. A sprite object with `x`, `y` `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n    b. A sprite object with `x`, `y` `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n    c. Optional: true or false to indicate whether or not the first sprite\n    should bounce off the second sprite.\n    */\n\n  }, {\n    key: \"rectangleCollision\",\n    value: function rectangleCollision(r1, r2) {\n      var bounce = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var global = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\n      //Add collision properties\n      if (!r1._bumpPropertiesAdded) this.addCollisionProperties(r1);\n      if (!r2._bumpPropertiesAdded) this.addCollisionProperties(r2);\n\n      var collision = undefined,\n          combinedHalfWidths = undefined,\n          combinedHalfHeights = undefined,\n          overlapX = undefined,\n          overlapY = undefined,\n          vx = undefined,\n          vy = undefined;\n\n      //Calculate the distance vector\n      if (global) {\n        vx = r1.gx + r1.halfWidth - r1.xAnchorOffset - (r2.gx + r2.halfWidth - r2.xAnchorOffset);\n        vy = r1.gy + r1.halfHeight - r1.yAnchorOffset - (r2.gy + r2.halfHeight - r2.yAnchorOffset);\n      } else {\n        //vx = r1.centerX - r2.centerX;\n        //vy = r1.centerY - r2.centerY;\n        vx = r1.x + r1.halfWidth - r1.xAnchorOffset - (r2.x + r2.halfWidth - r2.xAnchorOffset);\n        vy = r1.y + r1.halfHeight - r1.yAnchorOffset - (r2.y + r2.halfHeight - r2.yAnchorOffset);\n      }\n\n      //Figure out the combined half-widths and half-heights\n      combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n      combinedHalfHeights = r1.halfHeight + r2.halfHeight;\n\n      //Check whether vx is less than the combined half widths\n      if (Math.abs(vx) < combinedHalfWidths) {\n\n        //A collision might be occurring!\n        //Check whether vy is less than the combined half heights\n        if (Math.abs(vy) < combinedHalfHeights) {\n\n          //A collision has occurred! This is good!\n          //Find out the size of the overlap on both the X and Y axes\n          overlapX = combinedHalfWidths - Math.abs(vx);\n          overlapY = combinedHalfHeights - Math.abs(vy);\n\n          //The collision has occurred on the axis with the\n          //*smallest* amount of overlap. Let's figure out which\n          //axis that is\n\n          if (overlapX >= overlapY) {\n            //The collision is happening on the X axis\n            //But on which side? vy can tell us\n\n            if (vy > 0) {\n              collision = \"top\";\n              //Move the rectangle out of the collision\n              r1.y = r1.y + overlapY;\n            } else {\n              collision = \"bottom\";\n              //Move the rectangle out of the collision\n              r1.y = r1.y - overlapY;\n            }\n\n            //Bounce\n            if (bounce) {\n              r1.vy *= -1;\n\n              /*Alternative\n              //Find the bounce surface's vx and vy properties\n              var s = {};\n              s.vx = r2.x - r2.x + r2.width;\n              s.vy = 0;\n               //Bounce r1 off the surface\n              //this.bounceOffSurface(r1, s);\n              */\n            }\n          } else {\n              //The collision is happening on the Y axis\n              //But on which side? vx can tell us\n\n              if (vx > 0) {\n                collision = \"left\";\n                //Move the rectangle out of the collision\n                r1.x = r1.x + overlapX;\n              } else {\n                collision = \"right\";\n                //Move the rectangle out of the collision\n                r1.x = r1.x - overlapX;\n              }\n\n              //Bounce\n              if (bounce) {\n                r1.vx *= -1;\n\n                /*Alternative\n                //Find the bounce surface's vx and vy properties\n                var s = {};\n                s.vx = 0;\n                s.vy = r2.y - r2.y + r2.height;\n                 //Bounce r1 off the surface\n                this.bounceOffSurface(r1, s);\n                */\n              }\n            }\n        } else {\n            //No collision\n          }\n      } else {}\n        //No collision\n\n        //Return the collision string. it will be either \"top\", \"right\",\n        //\"bottom\", or \"left\" depending on which side of r1 is touching r2.\n      return collision;\n    }\n\n    /*\n    hitTestRectangle\n    ----------------\n     Use it to find out if two rectangular sprites are touching.\n    Parameters: \n    a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n    b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n     */\n\n  }, {\n    key: \"hitTestRectangle\",\n    value: function hitTestRectangle(r1, r2) {\n      var global = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Add collision properties\n      if (!r1._bumpPropertiesAdded) this.addCollisionProperties(r1);\n      if (!r2._bumpPropertiesAdded) this.addCollisionProperties(r2);\n\n      var hit = undefined,\n          combinedHalfWidths = undefined,\n          combinedHalfHeights = undefined,\n          vx = undefined,\n          vy = undefined;\n\n      //A variable to determine whether there's a collision\n      hit = false;\n\n      //Calculate the distance vector\n      if (global) {\n        vx = r1.gx + r1.halfWidth - r1.xAnchorOffset - (r2.gx + r2.halfWidth - r2.xAnchorOffset);\n        vy = r1.gy + r1.halfHeight - r1.yAnchorOffset - (r2.gy + r2.halfHeight - r2.yAnchorOffset);\n      } else {\n        vx = r1.x + r1.halfWidth - r1.xAnchorOffset - (r2.x + r2.halfWidth - r2.xAnchorOffset);\n        vy = r1.y + r1.halfHeight - r1.yAnchorOffset - (r2.y + r2.halfHeight - r2.yAnchorOffset);\n      }\n\n      //Figure out the combined half-widths and half-heights\n      combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n      combinedHalfHeights = r1.halfHeight + r2.halfHeight;\n\n      //Check for a collision on the x axis\n      if (Math.abs(vx) < combinedHalfWidths) {\n\n        //A collision might be occuring. Check for a collision on the y axis\n        if (Math.abs(vy) < combinedHalfHeights) {\n\n          //There's definitely a collision happening\n          hit = true;\n        } else {\n\n          //There's no collision on the y axis\n          hit = false;\n        }\n      } else {\n\n        //There's no collision on the x axis\n        hit = false;\n      }\n\n      //`hit` will be either `true` or `false`\n      return hit;\n    }\n\n    /*\n    hitTestCircleRectangle\n    ----------------\n     Use it to find out if a circular shape is touching a rectangular shape\n    Parameters: \n    a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n    b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n     */\n\n  }, {\n    key: \"hitTestCircleRectangle\",\n    value: function hitTestCircleRectangle(c1, r1) {\n      var global = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Add collision properties\n      if (!r1._bumpPropertiesAdded) this.addCollisionProperties(r1);\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n\n      var region = undefined,\n          collision = undefined,\n          c1x = undefined,\n          c1y = undefined,\n          r1x = undefined,\n          r1y = undefined;\n\n      //Use either global or local coordinates\n      if (global) {\n        c1x = c1.gx;\n        c1y = c1.gy;\n        r1x = r1.gx;\n        r1y = r1.gy;\n      } else {\n        c1x = c1.x;\n        c1y = c1.y;\n        r1x = r1.x;\n        r1y = r1.y;\n      }\n\n      //Is the circle above the rectangle's top edge?\n      if (c1y - c1.yAnchorOffset < r1y - r1.halfHeight - r1.yAnchorOffset) {\n\n        //If it is, we need to check whether it's in the\n        //top left, top center or top right\n        if (c1x - c1.xAnchorOffset < r1x - 1 - r1.halfWidth - r1.xAnchorOffset) {\n          region = \"topLeft\";\n        } else if (c1x - c1.xAnchorOffset > r1x + 1 + r1.halfWidth - r1.xAnchorOffset) {\n          region = \"topRight\";\n        } else {\n          region = \"topMiddle\";\n        }\n      }\n\n      //The circle isn't above the top edge, so it might be\n      //below the bottom edge\n      else if (c1y - c1.yAnchorOffset > r1y + r1.halfHeight - r1.yAnchorOffset) {\n\n          //If it is, we need to check whether it's in the bottom left,\n          //bottom center, or bottom right\n          if (c1x - c1.xAnchorOffset < r1x - 1 - r1.halfWidth - r1.xAnchorOffset) {\n            region = \"bottomLeft\";\n          } else if (c1x - c1.xAnchorOffset > r1x + 1 + r1.halfWidth - r1.xAnchorOffset) {\n            region = \"bottomRight\";\n          } else {\n            region = \"bottomMiddle\";\n          }\n        }\n\n        //The circle isn't above the top edge or below the bottom edge,\n        //so it must be on the left or right side\n        else {\n            if (c1x - c1.xAnchorOffset < r1x - r1.halfWidth - r1.xAnchorOffset) {\n              region = \"leftMiddle\";\n            } else {\n              region = \"rightMiddle\";\n            }\n          }\n\n      //Is this the circle touching the flat sides\n      //of the rectangle?\n      if (region === \"topMiddle\" || region === \"bottomMiddle\" || region === \"leftMiddle\" || region === \"rightMiddle\") {\n\n        //Yes, it is, so do a standard rectangle vs. rectangle collision test\n        collision = this.hitTestRectangle(c1, r1, global);\n      }\n\n      //The circle is touching one of the corners, so do a\n      //circle vs. point collision test\n      else {\n          var point = {};\n\n          switch (region) {\n            case \"topLeft\":\n              point.x = r1x - r1.xAnchorOffset;\n              point.y = r1y - r1.yAnchorOffset;\n              break;\n\n            case \"topRight\":\n              point.x = r1x + r1.width - r1.xAnchorOffset;\n              point.y = r1y - r1.yAnchorOffset;\n              break;\n\n            case \"bottomLeft\":\n              point.x = r1x - r1.xAnchorOffset;\n              point.y = r1y + r1.height - r1.yAnchorOffset;\n              break;\n\n            case \"bottomRight\":\n              point.x = r1x + r1.width - r1.xAnchorOffset;\n              point.y = r1y + r1.height - r1.yAnchorOffset;\n          }\n\n          //Check for a collision between the circle and the point\n          collision = this.hitTestCirclePoint(c1, point, global);\n        }\n\n      //Return the result of the collision.\n      //The return value will be `undefined` if there's no collision\n      if (collision) {\n        return region;\n      } else {\n        return collision;\n      }\n    }\n\n    /*\n    hitTestCirclePoint\n    ------------------\n     Use it to find out if a circular shape is touching a point\n    Parameters: \n    a. A sprite object with `centerX`, `centerY`, and `radius` properties.\n    b. A point object with `x` and `y` properties.\n     */\n\n  }, {\n    key: \"hitTestCirclePoint\",\n    value: function hitTestCirclePoint(c1, point) {\n      var global = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Add collision properties\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n\n      //A point is just a circle with a diameter of\n      //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n      //Collision test. Just supply the point with the properties\n      //it needs\n      point.diameter = 1;\n      point.width = point.diameter;\n      point.radius = 0.5;\n      point.centerX = point.x;\n      point.centerY = point.y;\n      point.gx = point.x;\n      point.gy = point.y;\n      point.xAnchorOffset = 0;\n      point.yAnchorOffset = 0;\n      point._bumpPropertiesAdded = true;\n      return this.hitTestCircle(c1, point, global);\n    }\n\n    /*\n    circleRectangleCollision\n    ------------------------\n     Use it to bounce a circular shape off a rectangular shape\n    Parameters: \n    a. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n    b. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\n     */\n\n  }, {\n    key: \"circleRectangleCollision\",\n    value: function circleRectangleCollision(c1, r1) {\n      var bounce = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var global = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n      //Add collision properties\n      if (!r1._bumpPropertiesAdded) this.addCollisionProperties(r1);\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n\n      var region = undefined,\n          collision = undefined,\n          c1x = undefined,\n          c1y = undefined,\n          r1x = undefined,\n          r1y = undefined;\n\n      //Use either the global or local coordinates\n      if (global) {\n        c1x = c1.gx;\n        c1y = c1.gy;\n        r1x = r1.gx;\n        r1y = r1.gy;\n      } else {\n        c1x = c1.x;\n        c1y = c1.y;\n        r1x = r1.x;\n        r1y = r1.y;\n      }\n\n      //Is the circle above the rectangle's top edge?\n      if (c1y - c1.yAnchorOffset < r1y - r1.halfHeight - r1.yAnchorOffset) {\n\n        //If it is, we need to check whether it's in the\n        //top left, top center or top right\n        if (c1x - c1.xAnchorOffset < r1x - 1 - r1.halfWidth - r1.xAnchorOffset) {\n          region = \"topLeft\";\n        } else if (c1x - c1.xAnchorOffset > r1x + 1 + r1.halfWidth - r1.xAnchorOffset) {\n          region = \"topRight\";\n        } else {\n          region = \"topMiddle\";\n        }\n      }\n\n      //The circle isn't above the top edge, so it might be\n      //below the bottom edge\n      else if (c1y - c1.yAnchorOffset > r1y + r1.halfHeight - r1.yAnchorOffset) {\n\n          //If it is, we need to check whether it's in the bottom left,\n          //bottom center, or bottom right\n          if (c1x - c1.xAnchorOffset < r1x - 1 - r1.halfWidth - r1.xAnchorOffset) {\n            region = \"bottomLeft\";\n          } else if (c1x - c1.xAnchorOffset > r1x + 1 + r1.halfWidth - r1.xAnchorOffset) {\n            region = \"bottomRight\";\n          } else {\n            region = \"bottomMiddle\";\n          }\n        }\n\n        //The circle isn't above the top edge or below the bottom edge,\n        //so it must be on the left or right side\n        else {\n            if (c1x - c1.xAnchorOffset < r1x - r1.halfWidth - r1.xAnchorOffset) {\n              region = \"leftMiddle\";\n            } else {\n              region = \"rightMiddle\";\n            }\n          }\n\n      //Is this the circle touching the flat sides\n      //of the rectangle?\n      if (region === \"topMiddle\" || region === \"bottomMiddle\" || region === \"leftMiddle\" || region === \"rightMiddle\") {\n\n        //Yes, it is, so do a standard rectangle vs. rectangle collision test\n        collision = this.rectangleCollision(c1, r1, bounce, global);\n      }\n\n      //The circle is touching one of the corners, so do a\n      //circle vs. point collision test\n      else {\n          var point = {};\n\n          switch (region) {\n            case \"topLeft\":\n              point.x = r1x - r1.xAnchorOffset;\n              point.y = r1y - r1.yAnchorOffset;\n              break;\n\n            case \"topRight\":\n              point.x = r1x + r1.width - r1.xAnchorOffset;\n              point.y = r1y - r1.yAnchorOffset;\n              break;\n\n            case \"bottomLeft\":\n              point.x = r1x - r1.xAnchorOffset;\n              point.y = r1y + r1.height - r1.yAnchorOffset;\n              break;\n\n            case \"bottomRight\":\n              point.x = r1x + r1.width - r1.xAnchorOffset;\n              point.y = r1y + r1.height - r1.yAnchorOffset;\n          }\n\n          //Check for a collision between the circle and the point\n          collision = this.circlePointCollision(c1, point, bounce, global);\n        }\n\n      if (collision) {\n        return region;\n      } else {\n        return collision;\n      }\n    }\n\n    /*\n    circlePointCollision\n    --------------------\n     Use it to boucnce a circle off a point.\n    Parameters: \n    a. A sprite object with `centerX`, `centerY`, and `radius` properties.\n    b. A point object with `x` and `y` properties.\n     */\n\n  }, {\n    key: \"circlePointCollision\",\n    value: function circlePointCollision(c1, point) {\n      var bounce = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var global = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n      //Add collision properties\n      if (!c1._bumpPropertiesAdded) this.addCollisionProperties(c1);\n\n      //A point is just a circle with a diameter of\n      //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n      //Collision test. Just supply the point with the properties\n      //it needs\n      point.diameter = 1;\n      point.width = point.diameter;\n      point.radius = 0.5;\n      point.centerX = point.x;\n      point.centerY = point.y;\n      point.gx = point.x;\n      point.gy = point.y;\n      point.xAnchorOffset = 0;\n      point.yAnchorOffset = 0;\n      point._bumpPropertiesAdded = true;\n      return this.circleCollision(c1, point, bounce, global);\n    }\n\n    /*\n    bounceOffSurface\n    ----------------\n     Use this to bounce an object off another object.\n    Parameters: \n    a. An object with `v.x` and `v.y` properties. This represents the object that is colliding\n    with a surface.\n    b. An object with `x` and `y` properties. This represents the surface that the object\n    is colliding into.\n    The first object can optionally have a mass property that's greater than 1. The mass will\n    be used to dampen the bounce effect.\n    */\n\n  }, {\n    key: \"bounceOffSurface\",\n    value: function bounceOffSurface(o, s) {\n\n      //Add collision properties\n      if (!o._bumpPropertiesAdded) this.addCollisionProperties(o);\n\n      var dp1 = undefined,\n          dp2 = undefined,\n          p1 = {},\n          p2 = {},\n          bounce = {},\n          mass = o.mass || 1;\n\n      //1. Calculate the collision surface's properties\n      //Find the surface vector's left normal\n      s.lx = s.y;\n      s.ly = -s.x;\n\n      //Find its magnitude\n      s.magnitude = Math.sqrt(s.x * s.x + s.y * s.y);\n\n      //Find its normalized values\n      s.dx = s.x / s.magnitude;\n      s.dy = s.y / s.magnitude;\n\n      //2. Bounce the object (o) off the surface (s)\n\n      //Find the dot product between the object and the surface\n      dp1 = o.vx * s.dx + o.vy * s.dy;\n\n      //Project the object's velocity onto the collision surface\n      p1.vx = dp1 * s.dx;\n      p1.vy = dp1 * s.dy;\n\n      //Find the dot product of the object and the surface's left normal (s.lx and s.ly)\n      dp2 = o.vx * (s.lx / s.magnitude) + o.vy * (s.ly / s.magnitude);\n\n      //Project the object's velocity onto the surface's left normal\n      p2.vx = dp2 * (s.lx / s.magnitude);\n      p2.vy = dp2 * (s.ly / s.magnitude);\n\n      //Reverse the projection on the surface's left normal\n      p2.vx *= -1;\n      p2.vy *= -1;\n\n      //Add up the projections to create a new bounce vector\n      bounce.x = p1.vx + p2.vx;\n      bounce.y = p1.vy + p2.vy;\n\n      //Assign the bounce vector to the object's velocity\n      //with optional mass to dampen the effect\n      o.vx = bounce.x / mass;\n      o.vy = bounce.y / mass;\n    }\n\n    /*\n    contain\n    -------\n    `contain` can be used to contain a sprite with `x` and\n    `y` properties inside a rectangular area.\n     The `contain` function takes four arguments: a sprite with `x` and `y`\n    properties, an object literal with `x`, `y`, `width` and `height` properties. The \n    third argument is a Boolean (true/false) value that determines if the sprite\n    should bounce when it hits the edge of the container. The fourth argument\n    is an extra user-defined callback function that you can call when the\n    sprite hits the container\n    ```js\n    contain(anySprite, {x: 0, y: 0, width: 512, height: 512}, true, callbackFunction);\n    ```\n    The code above will contain the sprite's position inside the 512 by\n    512 pixel area defined by the object. If the sprite hits the edges of\n    the container, it will bounce. The `callBackFunction` will run if \n    there's a collision.\n     An additional feature of the `contain` method is that if the sprite\n    has a `mass` property, it will be used to dampen the sprite's bounce\n    in a natural looking way.\n     If the sprite bumps into any of the containing object's boundaries,\n    the `contain` function will return a value that tells you which side\n    the sprite bumped into: “left”, “top”, “right” or “bottom”. Here's how\n    you could keep the sprite contained and also find out which boundary\n    it hit:\n    ```js\n    //Contain the sprite and find the collision value\n    let collision = contain(anySprite, {x: 0, y: 0, width: 512, height: 512});\n     //If there's a collision, display the boundary that the collision happened on\n    if(collision) {\n      if collision.has(\"left\") console.log(\"The sprite hit the left\");  \n      if collision.has(\"top\") console.log(\"The sprite hit the top\");  \n      if collision.has(\"right\") console.log(\"The sprite hit the right\");  \n      if collision.has(\"bottom\") console.log(\"The sprite hit the bottom\");  \n    }\n    ```\n    If the sprite doesn't hit a boundary, the value of\n    `collision` will be `undefined`. \n    */\n\n    /*\n     contain(sprite, container, bounce = false, extra = undefined) {\n        //Helper methods that compensate for any possible shift the the\n       //sprites' anchor points\n       let nudgeAnchor = (o, value, axis) => {\n         if (o.anchor !== undefined) {\n           if (o.anchor[axis] !== 0) {\n             return value * ((1 - o.anchor[axis]) - o.anchor[axis]);\n           } else {\n             return value;\n           }\n         } else {\n           return value; \n         }\n       };\n        let compensateForAnchor = (o, value, axis) => {\n         if (o.anchor !== undefined) {\n           if (o.anchor[axis] !== 0) {\n             return value * o.anchor[axis];\n           } else {\n             return 0;\n           }\n         } else {\n           return 0; \n         }\n       };\n        let compensateForAnchors = (a, b, property1, property2) => {\n          return compensateForAnchor(a, a[property1], property2) + compensateForAnchor(b, b[property1], property2)\n       };    \n       //Create a set called `collision` to keep track of the\n       //boundaries with which the sprite is colliding\n       let collision = new Set();\n        //Left\n       if (sprite.x - compensateForAnchor(sprite, sprite.width, \"x\") < container.x - sprite.parent.gx - compensateForAnchor(container, container.width, \"x\")) {\n         //Bounce the sprite if `bounce` is true\n         if (bounce) sprite.vx *= -1;\n          //If the sprite has `mass`, let the mass\n         //affect the sprite's velocity\n         if(sprite.mass) sprite.vx /= sprite.mass;\n          //Keep the sprite inside the container\n         sprite.x = container.x - sprite.parent.gx + compensateForAnchor(sprite, sprite.width, \"x\") - compensateForAnchor(container, container.width, \"x\");\n          //Add \"left\" to the collision set\n         collision.add(\"left\");\n       }\n        //Top\n       if (sprite.y - compensateForAnchor(sprite, sprite.height, \"y\") < container.y - sprite.parent.gy - compensateForAnchor(container, container.height, \"y\")) {\n         if (bounce) sprite.vy *= -1;\n         if(sprite.mass) sprite.vy /= sprite.mass;\n         sprite.y = container.x - sprite.parent.gy + compensateForAnchor(sprite, sprite.height, \"y\") - compensateForAnchor(container, container.height, \"y\");\n         collision.add(\"top\");\n       }\n        //Right\n       if (sprite.x - compensateForAnchor(sprite, sprite.width, \"x\") + sprite.width > container.width - compensateForAnchor(container, container.width, \"x\")) {\n         if (bounce) sprite.vx *= -1;\n         if(sprite.mass) sprite.vx /= sprite.mass;\n         sprite.x = container.width - sprite.width + compensateForAnchor(sprite, sprite.width, \"x\") - compensateForAnchor(container, container.width, \"x\");\n         collision.add(\"right\");\n       }\n        //Bottom\n       if (sprite.y - compensateForAnchor(sprite, sprite.height, \"y\") + sprite.height > container.height - compensateForAnchor(container, container.height, \"y\")) {\n         if (bounce) sprite.vy *= -1;\n         if(sprite.mass) sprite.vy /= sprite.mass;\n         sprite.y = container.height - sprite.height + compensateForAnchor(sprite, sprite.height, \"y\") - compensateForAnchor(container, container.height, \"y\");\n         collision.add(\"bottom\");\n       }\n        //If there were no collisions, set `collision` to `undefined`\n       if (collision.size === 0) collision = undefined;\n        //The `extra` function runs if there was a collision\n       //and `extra` has been defined\n       if (collision && extra) extra(collision);\n        //Return the `collision` value\n       return collision;\n     }\n     */\n\n  }, {\n    key: \"contain\",\n    value: function contain(sprite, container) {\n      var bounce = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var extra = arguments.length <= 3 || arguments[3] === undefined ? undefined : arguments[3];\n\n      //Add collision properties\n      if (!sprite._bumpPropertiesAdded) this.addCollisionProperties(sprite);\n\n      //Give the container x and y anchor offset values, if it doesn't\n      //have any\n      if (container.xAnchorOffset === undefined) container.xAnchorOffset = 0;\n      if (container.yAnchorOffset === undefined) container.yAnchorOffset = 0;\n      if (sprite.parent.gx === undefined) sprite.parent.gx = 0;\n      if (sprite.parent.gy === undefined) sprite.parent.gy = 0;\n\n      //Create a Set called `collision` to keep track of the\n      //boundaries with which the sprite is colliding\n      var collision = new Set();\n\n      //Left\n      if (sprite.x - sprite.xAnchorOffset < container.x - sprite.parent.gx - container.xAnchorOffset) {\n\n        //Bounce the sprite if `bounce` is true\n        if (bounce) sprite.vx *= -1;\n\n        //If the sprite has `mass`, let the mass\n        //affect the sprite's velocity\n        if (sprite.mass) sprite.vx /= sprite.mass;\n\n        //Reposition the sprite inside the container\n        sprite.x = container.x - sprite.parent.gx - container.xAnchorOffset + sprite.xAnchorOffset;\n\n        //Make a record of the side which the container hit\n        collision.add(\"left\");\n      }\n\n      //Top\n      if (sprite.y - sprite.yAnchorOffset < container.y - sprite.parent.gy - container.yAnchorOffset) {\n        if (bounce) sprite.vy *= -1;\n        if (sprite.mass) sprite.vy /= sprite.mass;\n        sprite.y = container.y - sprite.parent.gy - container.yAnchorOffset + sprite.yAnchorOffset;;\n        collision.add(\"top\");\n      }\n\n      //Right\n      if (sprite.x - sprite.xAnchorOffset + sprite.width > container.width - container.xAnchorOffset) {\n        if (bounce) sprite.vx *= -1;\n        if (sprite.mass) sprite.vx /= sprite.mass;\n        sprite.x = container.width - sprite.width - container.xAnchorOffset + sprite.xAnchorOffset;\n        collision.add(\"right\");\n      }\n\n      //Bottom\n      if (sprite.y - sprite.yAnchorOffset + sprite.height > container.height - container.yAnchorOffset) {\n        if (bounce) sprite.vy *= -1;\n        if (sprite.mass) sprite.vy /= sprite.mass;\n        sprite.y = container.height - sprite.height - container.yAnchorOffset + sprite.yAnchorOffset;\n        collision.add(\"bottom\");\n      }\n\n      //If there were no collisions, set `collision` to `undefined`\n      if (collision.size === 0) collision = undefined;\n\n      //The `extra` function runs if there was a collision\n      //and `extra` has been defined\n      if (collision && extra) extra(collision);\n\n      //Return the `collision` value\n      return collision;\n    }\n\n    //`outsideBounds` checks whether a sprite is outide the boundary of\n    //another object. It returns an object called `collision`. `collision` will be `undefined` if there's no\n    //collision. But if there is a collision, `collision` will be\n    //returned as a Set containg strings that tell you which boundary\n    //side was crossed: \"left\", \"right\", \"top\" or \"bottom\"\n\n  }, {\n    key: \"outsideBounds\",\n    value: function outsideBounds(s, bounds, extra) {\n\n      var x = bounds.x,\n          y = bounds.y,\n          width = bounds.width,\n          height = bounds.height;\n\n      //The `collision` object is used to store which\n      //side of the containing rectangle the sprite hits\n      var collision = new Set();\n\n      //Left\n      if (s.x < x - s.width) {\n        collision.add(\"left\");\n      }\n      //Top\n      if (s.y < y - s.height) {\n        collision.add(\"top\");\n      }\n      //Right\n      if (s.x > width + s.width) {\n        collision.add(\"right\");\n      }\n      //Bottom\n      if (s.y > height + s.height) {\n        collision.add(\"bottom\");\n      }\n\n      //If there were no collisions, set `collision` to `undefined`\n      if (collision.size === 0) collision = undefined;\n\n      //The `extra` function runs if there was a collision\n      //and `extra` has been defined\n      if (collision && extra) extra(collision);\n\n      //Return the `collision` object\n      return collision;\n    }\n\n    /*\n    _getCenter\n    ----------\n     A utility that finds the center point of the sprite. If it's anchor point is the\n    sprite's top left corner, then the center is calculated from that point.\n    If the anchor point has been shifted, then the anchor x/y point is used as the sprite's center\n    */\n\n  }, {\n    key: \"_getCenter\",\n    value: function _getCenter(o, dimension, axis) {\n      if (o.anchor !== undefined) {\n        if (o.anchor[axis] !== 0) {\n          return 0;\n        } else {\n          //console.log(o.anchor[axis])\n          return dimension / 2;\n        }\n      } else {\n        return dimension;\n      }\n    }\n\n    /*\n    hit\n    ---\n    A convenient universal collision function to test for collisions\n    between rectangles, circles, and points.\n    */\n\n  }, {\n    key: \"hit\",\n    value: function hit(a, b) {\n      var react = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var bounce = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n      var global = arguments[4];\n      var extra = arguments.length <= 5 || arguments[5] === undefined ? undefined : arguments[5];\n\n      //Local references to bump's collision methods\n      var hitTestPoint = this.hitTestPoint.bind(this),\n          hitTestRectangle = this.hitTestRectangle.bind(this),\n          hitTestCircle = this.hitTestCircle.bind(this),\n          movingCircleCollision = this.movingCircleCollision.bind(this),\n          circleCollision = this.circleCollision.bind(this),\n          hitTestCircleRectangle = this.hitTestCircleRectangle.bind(this),\n          rectangleCollision = this.rectangleCollision.bind(this),\n          circleRectangleCollision = this.circleRectangleCollision.bind(this);\n\n      var collision = undefined,\n          aIsASprite = a.parent !== undefined,\n          bIsASprite = b.parent !== undefined;\n\n      //Check to make sure one of the arguments isn't an array\n      if (aIsASprite && b instanceof Array || bIsASprite && a instanceof Array) {\n        //If it is, check for a collision between a sprite and an array\n        spriteVsArray();\n      } else {\n        //If one of the arguments isn't an array, find out what type of\n        //collision check to run\n        collision = findCollisionType(a, b);\n        if (collision && extra) extra(collision);\n      }\n\n      //Return the result of the collision.\n      //It will be `undefined` if there's no collision and `true` if\n      //there is a collision. `rectangleCollision` sets `collsision` to\n      //\"top\", \"bottom\", \"left\" or \"right\" depeneding on which side the\n      //collision is occuring on\n      return collision;\n\n      function findCollisionType(a, b) {\n        //Are `a` and `b` both sprites?\n        //(We have to check again if this function was called from\n        //`spriteVsArray`)\n        var aIsASprite = a.parent !== undefined;\n        var bIsASprite = b.parent !== undefined;\n\n        if (aIsASprite && bIsASprite) {\n          //Yes, but what kind of sprites?\n          if (a.diameter && b.diameter) {\n            //They're circles\n            return circleVsCircle(a, b);\n          } else if (a.diameter && !b.diameter) {\n            //The first one is a circle and the second is a rectangle\n            return circleVsRectangle(a, b);\n          } else {\n            //They're rectangles\n            return rectangleVsRectangle(a, b);\n          }\n        }\n        //They're not both sprites, so what are they?\n        //Is `a` not a sprite and does it have x and y properties?\n        else if (bIsASprite && !(a.x === undefined) && !(a.y === undefined)) {\n            //Yes, so this is a point vs. sprite collision test\n            return hitTestPoint(a, b);\n          } else {\n            //The user is trying to test some incompatible objects\n            throw new Error(\"I'm sorry, \" + a + \" and \" + b + \" cannot be use together in a collision test.'\");\n          }\n      }\n\n      function spriteVsArray() {\n        //If `a` happens to be the array, flip it around so that it becomes `b`\n        if (a instanceof Array) {\n          var _ref = [_b, _a];\n          var _a = _ref[0];\n          var _b = _ref[1];\n        }\n        //Loop through the array in reverse\n        for (var i = b.length - 1; i >= 0; i--) {\n          var sprite = b[i];\n          collision = findCollisionType(a, sprite);\n          if (collision && extra) extra(collision, sprite);\n        }\n      }\n\n      function circleVsCircle(a, b) {\n        //If the circles shouldn't react to the collision,\n        //just test to see if they're touching\n        if (!react) {\n          return hitTestCircle(a, b);\n        }\n        //Yes, the circles should react to the collision\n        else {\n            //Are they both moving?\n            if (a.vx + a.vy !== 0 && b.vx + b.vy !== 0) {\n              //Yes, they are both moving\n              //(moving circle collisions always bounce apart so there's\n              //no need for the third, `bounce`, argument)\n              return movingCircleCollision(a, b, global);\n            } else {\n              //No, they're not both moving\n              return circleCollision(a, b, bounce, global);\n            }\n          }\n      }\n\n      function rectangleVsRectangle(a, b) {\n        //If the rectangles shouldn't react to the collision, just\n        //test to see if they're touching\n        if (!react) {\n          return hitTestRectangle(a, b, global);\n        } else {\n          return rectangleCollision(a, b, bounce, global);\n        }\n      }\n\n      function circleVsRectangle(a, b) {\n        //If the rectangles shouldn't react to the collision, just\n        //test to see if they're touching\n        if (!react) {\n          return hitTestCircleRectangle(a, b, global);\n        } else {\n          return circleRectangleCollision(a, b, bounce, global);\n        }\n      }\n    }\n  }]);\n\n  return Bump;\n})();\n//# sourceMappingURL=bump.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Charm = (function () {\n  function Charm() {\n    var _this = this;\n\n    var renderingEngine = arguments.length <= 0 || arguments[0] === undefined ? PIXI : arguments[0];\n\n    _classCallCheck(this, Charm);\n\n    if (renderingEngine === undefined) throw new Error(\"Please assign a rendering engine in the constructor before using charm.js\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderer = \"pixi\";\n    }\n\n    //An array to store the global tweens\n    this.globalTweens = [];\n\n    //An object that stores all the easing formulas\n    this.easingFormulas = {\n\n      //Linear\n\n      linear: function linear(x) {\n        return x;\n      },\n\n      //Smoothstep\n      smoothstep: function smoothstep(x) {\n        return x * x * (3 - 2 * x);\n      },\n      smoothstepSquared: function smoothstepSquared(x) {\n        return Math.pow(x * x * (3 - 2 * x), 2);\n      },\n      smoothstepCubed: function smoothstepCubed(x) {\n        return Math.pow(x * x * (3 - 2 * x), 3);\n      },\n\n      //Acceleration\n      acceleration: function acceleration(x) {\n        return x * x;\n      },\n      accelerationCubed: function accelerationCubed(x) {\n        return Math.pow(x * x, 3);\n      },\n\n      //Deceleration\n      deceleration: function deceleration(x) {\n        return 1 - Math.pow(1 - x, 2);\n      },\n      decelerationCubed: function decelerationCubed(x) {\n        return 1 - Math.pow(1 - x, 3);\n      },\n\n      //Sine\n      sine: function sine(x) {\n        return Math.sin(x * Math.PI / 2);\n      },\n      sineSquared: function sineSquared(x) {\n        return Math.pow(Math.sin(x * Math.PI / 2), 2);\n      },\n      sineCubed: function sineCubed(x) {\n        return Math.pow(Math.sin(x * Math.PI / 2), 2);\n      },\n      inverseSine: function inverseSine(x) {\n        return 1 - Math.sin((1 - x) * Math.PI / 2);\n      },\n      inverseSineSquared: function inverseSineSquared(x) {\n        return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 2);\n      },\n      inverseSineCubed: function inverseSineCubed(x) {\n        return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 3);\n      },\n\n      //Spline\n      spline: function spline(t, p0, p1, p2, p3) {\n        return 0.5 * (2 * p1 + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);\n      },\n\n      //Bezier curve\n      cubicBezier: function cubicBezier(t, a, b, c, d) {\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return a + (-a * 3 + t * (3 * a - a * t)) * t + (3 * b + t * (-6 * b + b * 3 * t)) * t + (c * 3 - c * 3 * t) * t2 + d * t3;\n      }\n    };\n\n    //Add `scaleX` and `scaleY` properties to Pixi sprites\n    this._addScaleProperties = function (sprite) {\n      if (_this.renderer === \"pixi\") {\n        if (!sprite.scaleX && sprite.scale.x) {\n          Object.defineProperty(sprite, \"scaleX\", {\n            get: function get() {\n              return sprite.scale.x;\n            },\n            set: function set(value) {\n              sprite.scale.x = value;\n            }\n          });\n        }\n        if (!sprite.scaleY && sprite.scale.y) {\n          Object.defineProperty(sprite, \"scaleY\", {\n            get: function get() {\n              return sprite.scale.y;\n            },\n            set: function set(value) {\n              sprite.scale.y = value;\n            }\n          });\n        }\n      }\n    };\n  }\n\n  //The low level `tweenProperty` function is used as the foundation\n  //for the the higher level tween methods.\n\n  _createClass(Charm, [{\n    key: \"tweenProperty\",\n    value: function tweenProperty(sprite, //Sprite object\n    property, //String property\n    startValue, //Tween start value\n    endValue, //Tween end value\n    totalFrames) //Delay in frames before repeating\n    {\n      var type = arguments.length <= 5 || arguments[5] === undefined ? \"smoothstep\" : arguments[5];\n\n      var _this2 = this;\n\n      var yoyo = arguments.length <= 6 || arguments[6] === undefined ? false : arguments[6];\n      var delayBeforeRepeat = arguments.length <= 7 || arguments[7] === undefined ? 0 : arguments[7];\n\n      //Create the tween object\n      var o = {};\n\n      //If the tween is a bounce type (a spline), set the\n      //start and end magnitude values\n      var typeArray = type.split(\" \");\n      if (typeArray[0] === \"bounce\") {\n        o.startMagnitude = parseInt(typeArray[1]);\n        o.endMagnitude = parseInt(typeArray[2]);\n      }\n\n      //Use `o.start` to make a new tween using the current\n      //end point values\n      o.start = function (startValue, endValue) {\n\n        //Clone the start and end values so that any possible references to sprite\n        //properties are converted to ordinary numbers\n        o.startValue = JSON.parse(JSON.stringify(startValue));\n        o.endValue = JSON.parse(JSON.stringify(endValue));\n        o.playing = true;\n        o.totalFrames = totalFrames;\n        o.frameCounter = 0;\n\n        //Add the tween to the global `tweens` array. The `tweens` array is\n        //updated on each frame\n        _this2.globalTweens.push(o);\n      };\n\n      //Call `o.start` to start the tween\n      o.start(startValue, endValue);\n\n      //The `update` method will be called on each frame by the game loop.\n      //This is what makes the tween move\n      o.update = function () {\n\n        var time = undefined,\n            curvedTime = undefined;\n\n        if (o.playing) {\n\n          //If the elapsed frames are less than the total frames,\n          //use the tweening formulas to move the sprite\n          if (o.frameCounter < o.totalFrames) {\n\n            //Find the normalized value\n            var normalizedTime = o.frameCounter / o.totalFrames;\n\n            //Select the correct easing function from the\n            //`ease` object’s library of easing functions\n\n            //If it's not a spline, use one of the ordinary easing functions\n            if (typeArray[0] !== \"bounce\") {\n              curvedTime = _this2.easingFormulas[type](normalizedTime);\n            }\n\n            //If it's a spline, use the `spline` function and apply the\n            //2 additional `type` array values as the spline's start and\n            //end points\n            else {\n                curvedTime = _this2.easingFormulas.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n              }\n\n            //Interpolate the sprite's property based on the curve\n            sprite[property] = o.endValue * curvedTime + o.startValue * (1 - curvedTime);\n\n            o.frameCounter += 1;\n          }\n\n          //When the tween has finished playing, run the end tasks\n          else {\n              sprite[property] = o.endValue;\n              o.end();\n            }\n        }\n      };\n\n      //The `end` method will be called when the tween is finished\n      o.end = function () {\n\n        //Set `playing` to `false`\n        o.playing = false;\n\n        //Call the tween's `onComplete` method, if it's been assigned\n        if (o.onComplete) o.onComplete();\n\n        //Remove the tween from the `tweens` array\n        _this2.globalTweens.splice(_this2.globalTweens.indexOf(o), 1);\n\n        //If the tween's `yoyo` property is `true`, create a new tween\n        //using the same values, but use the current tween's `startValue`\n        //as the next tween's `endValue`\n        if (yoyo) {\n          _this2.wait(delayBeforeRepeat).then(function () {\n            o.start(o.endValue, o.startValue);\n          });\n        }\n      };\n\n      //Pause and play methods\n      o.play = function () {\n        return o.playing = true;\n      };\n      o.pause = function () {\n        return o.playing = false;\n      };\n\n      //Return the tween object\n      return o;\n    }\n\n    //`makeTween` is a general low-level method for making complex tweens\n    //out of multiple `tweenProperty` functions. Its one argument,\n    //`tweensToAdd` is an array containing multiple `tweenProperty` calls\n\n  }, {\n    key: \"makeTween\",\n    value: function makeTween(tweensToAdd) {\n      var _this3 = this;\n\n      //Create an object to manage the tweens\n      var o = {};\n\n      //Create a `tweens` array to store the new tweens\n      o.tweens = [];\n\n      //Make a new tween for each array\n      tweensToAdd.forEach(function (tweenPropertyArguments) {\n\n        //Use the tween property arguments to make a new tween\n        var newTween = _this3.tweenProperty.apply(_this3, _toConsumableArray(tweenPropertyArguments));\n\n        //Push the new tween into this object's internal `tweens` array\n        o.tweens.push(newTween);\n      });\n\n      //Add a counter to keep track of the\n      //number of tweens that have completed their actions\n      var completionCounter = 0;\n\n      //`o.completed` will be called each time one of the tweens\n      //finishes\n      o.completed = function () {\n\n        //Add 1 to the `completionCounter`\n        completionCounter += 1;\n\n        //If all tweens have finished, call the user-defined `onComplete`\n        //method, if it's been assigned. Reset the `completionCounter`\n        if (completionCounter === o.tweens.length) {\n          if (o.onComplete) o.onComplete();\n          completionCounter = 0;\n        }\n      };\n\n      //Add `onComplete` methods to all tweens\n      o.tweens.forEach(function (tween) {\n        tween.onComplete = function () {\n          return o.completed();\n        };\n      });\n\n      //Add pause and play methods to control all the tweens\n      o.pause = function () {\n        o.tweens.forEach(function (tween) {\n          tween.playing = false;\n        });\n      };\n      o.play = function () {\n        o.tweens.forEach(function (tween) {\n          tween.playing = true;\n        });\n      };\n\n      //Return the tween object\n      return o;\n    }\n\n    /* High level tween methods */\n\n    //1. Simple tweens\n\n    //`fadeOut`\n\n  }, {\n    key: \"fadeOut\",\n    value: function fadeOut(sprite) {\n      var frames = arguments.length <= 1 || arguments[1] === undefined ? 60 : arguments[1];\n\n      return this.tweenProperty(sprite, \"alpha\", sprite.alpha, 0, frames, \"sine\");\n    }\n\n    //`fadeIn`\n\n  }, {\n    key: \"fadeIn\",\n    value: function fadeIn(sprite) {\n      var frames = arguments.length <= 1 || arguments[1] === undefined ? 60 : arguments[1];\n\n      return this.tweenProperty(sprite, \"alpha\", sprite.alpha, 1, frames, \"sine\");\n    }\n\n    //`pulse`\n    //Fades the sprite in and out at a steady rate.\n    //Set the `minAlpha` to something greater than 0 if you\n    //don't want the sprite to fade away completely\n\n  }, {\n    key: \"pulse\",\n    value: function pulse(sprite) {\n      var frames = arguments.length <= 1 || arguments[1] === undefined ? 60 : arguments[1];\n      var minAlpha = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n      return this.tweenProperty(sprite, \"alpha\", sprite.alpha, minAlpha, frames, \"smoothstep\", true);\n    }\n\n    //2. Complex tweens\n\n  }, {\n    key: \"slide\",\n    value: function slide(sprite, endX, endY) {\n      var frames = arguments.length <= 3 || arguments[3] === undefined ? 60 : arguments[3];\n      var type = arguments.length <= 4 || arguments[4] === undefined ? \"smoothstep\" : arguments[4];\n      var yoyo = arguments.length <= 5 || arguments[5] === undefined ? false : arguments[5];\n      var delayBeforeRepeat = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n\n      return this.makeTween([\n\n      //Create the x axis tween\n      [sprite, \"x\", sprite.x, endX, frames, type, yoyo, delayBeforeRepeat],\n\n      //Create the y axis tween\n      [sprite, \"y\", sprite.y, endY, frames, type, yoyo, delayBeforeRepeat]]);\n    }\n  }, {\n    key: \"breathe\",\n    value: function breathe(sprite) {\n      var endScaleX = arguments.length <= 1 || arguments[1] === undefined ? 0.8 : arguments[1];\n      var endScaleY = arguments.length <= 2 || arguments[2] === undefined ? 0.8 : arguments[2];\n      var frames = arguments.length <= 3 || arguments[3] === undefined ? 60 : arguments[3];\n      var yoyo = arguments.length <= 4 || arguments[4] === undefined ? true : arguments[4];\n      var delayBeforeRepeat = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n      //Add `scaleX` and `scaleY` properties to Pixi sprites\n      this._addScaleProperties(sprite);\n\n      return this.makeTween([\n\n      //Create the scaleX tween\n      [sprite, \"scaleX\", sprite.scaleX, endScaleX, frames, \"smoothstepSquared\", yoyo, delayBeforeRepeat],\n\n      //Create the scaleY tween\n      [sprite, \"scaleY\", sprite.scaleY, endScaleY, frames, \"smoothstepSquared\", yoyo, delayBeforeRepeat]]);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sprite) {\n      var endScaleX = arguments.length <= 1 || arguments[1] === undefined ? 0.5 : arguments[1];\n      var endScaleY = arguments.length <= 2 || arguments[2] === undefined ? 0.5 : arguments[2];\n      var frames = arguments.length <= 3 || arguments[3] === undefined ? 60 : arguments[3];\n\n      //Add `scaleX` and `scaleY` properties to Pixi sprites\n      this._addScaleProperties(sprite);\n\n      return this.makeTween([\n\n      //Create the scaleX tween\n      [sprite, \"scaleX\", sprite.scaleX, endScaleX, frames, \"smoothstep\", false],\n\n      //Create the scaleY tween\n      [sprite, \"scaleY\", sprite.scaleY, endScaleY, frames, \"smoothstep\", false]]);\n    }\n  }, {\n    key: \"strobe\",\n    value: function strobe(sprite) {\n      var scaleFactor = arguments.length <= 1 || arguments[1] === undefined ? 1.3 : arguments[1];\n      var startMagnitude = arguments.length <= 2 || arguments[2] === undefined ? 10 : arguments[2];\n      var endMagnitude = arguments.length <= 3 || arguments[3] === undefined ? 20 : arguments[3];\n      var frames = arguments.length <= 4 || arguments[4] === undefined ? 10 : arguments[4];\n      var yoyo = arguments.length <= 5 || arguments[5] === undefined ? true : arguments[5];\n      var delayBeforeRepeat = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n\n      var bounce = \"bounce \" + startMagnitude + \" \" + endMagnitude;\n\n      //Add `scaleX` and `scaleY` properties to Pixi sprites\n      this._addScaleProperties(sprite);\n\n      return this.makeTween([\n\n      //Create the scaleX tween\n      [sprite, \"scaleX\", sprite.scaleX, scaleFactor, frames, bounce, yoyo, delayBeforeRepeat],\n\n      //Create the scaleY tween\n      [sprite, \"scaleY\", sprite.scaleY, scaleFactor, frames, bounce, yoyo, delayBeforeRepeat]]);\n    }\n  }, {\n    key: \"wobble\",\n    value: function wobble(sprite) {\n      var scaleFactorX = arguments.length <= 1 || arguments[1] === undefined ? 1.2 : arguments[1];\n      var scaleFactorY = arguments.length <= 2 || arguments[2] === undefined ? 1.2 : arguments[2];\n      var frames = arguments.length <= 3 || arguments[3] === undefined ? 10 : arguments[3];\n      var xStartMagnitude = arguments.length <= 4 || arguments[4] === undefined ? 10 : arguments[4];\n      var xEndMagnitude = arguments.length <= 5 || arguments[5] === undefined ? 10 : arguments[5];\n      var yStartMagnitude = arguments.length <= 6 || arguments[6] === undefined ? -10 : arguments[6];\n      var yEndMagnitude = arguments.length <= 7 || arguments[7] === undefined ? -10 : arguments[7];\n      var friction = arguments.length <= 8 || arguments[8] === undefined ? 0.98 : arguments[8];\n\n      var _this4 = this;\n\n      var yoyo = arguments.length <= 9 || arguments[9] === undefined ? true : arguments[9];\n      var delayBeforeRepeat = arguments.length <= 10 || arguments[10] === undefined ? 0 : arguments[10];\n\n      var bounceX = \"bounce \" + xStartMagnitude + \" \" + xEndMagnitude;\n      var bounceY = \"bounce \" + yStartMagnitude + \" \" + yEndMagnitude;\n\n      //Add `scaleX` and `scaleY` properties to Pixi sprites\n      this._addScaleProperties(sprite);\n\n      var o = this.makeTween([\n\n      //Create the scaleX tween\n      [sprite, \"scaleX\", sprite.scaleX, scaleFactorX, frames, bounceX, yoyo, delayBeforeRepeat],\n\n      //Create the scaleY tween\n      [sprite, \"scaleY\", sprite.scaleY, scaleFactorY, frames, bounceY, yoyo, delayBeforeRepeat]]);\n\n      //Add some friction to the `endValue` at the end of each tween\n      o.tweens.forEach(function (tween) {\n        tween.onComplete = function () {\n\n          //Add friction if the `endValue` is greater than 1\n          if (tween.endValue > 1) {\n            tween.endValue *= friction;\n\n            //Set the `endValue` to 1 when the effect is finished and\n            //remove the tween from the global `tweens` array\n            if (tween.endValue <= 1) {\n              tween.endValue = 1;\n              _this4.removeTween(tween);\n            }\n          }\n        };\n      });\n\n      return o;\n    }\n\n    //3. Motion path tweens\n\n  }, {\n    key: \"followCurve\",\n    value: function followCurve(sprite, pointsArray, totalFrames) {\n      var type = arguments.length <= 3 || arguments[3] === undefined ? \"smoothstep\" : arguments[3];\n\n      var _this5 = this;\n\n      var yoyo = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n      var delayBeforeRepeat = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n      //Create the tween object\n      var o = {};\n\n      //If the tween is a bounce type (a spline), set the\n      //start and end magnitude values\n      var typeArray = type.split(\" \");\n      if (typeArray[0] === \"bounce\") {\n        o.startMagnitude = parseInt(typeArray[1]);\n        o.endMagnitude = parseInt(typeArray[2]);\n      }\n\n      //Use `tween.start` to make a new tween using the current\n      //end point values\n      o.start = function (pointsArray) {\n        o.playing = true;\n        o.totalFrames = totalFrames;\n        o.frameCounter = 0;\n\n        //Clone the points array\n        o.pointsArray = JSON.parse(JSON.stringify(pointsArray));\n\n        //Add the tween to the `globalTweens` array. The `globalTweens` array is\n        //updated on each frame\n        _this5.globalTweens.push(o);\n      };\n\n      //Call `tween.start` to start the first tween\n      o.start(pointsArray);\n\n      //The `update` method will be called on each frame by the game loop.\n      //This is what makes the tween move\n      o.update = function () {\n\n        var normalizedTime = undefined,\n            curvedTime = undefined,\n            p = o.pointsArray;\n\n        if (o.playing) {\n\n          //If the elapsed frames are less than the total frames,\n          //use the tweening formulas to move the sprite\n          if (o.frameCounter < o.totalFrames) {\n\n            //Find the normalized value\n            normalizedTime = o.frameCounter / o.totalFrames;\n\n            //Select the correct easing function\n\n            //If it's not a spline, use one of the ordinary tween\n            //functions\n            if (typeArray[0] !== \"bounce\") {\n              curvedTime = _this5.easingFormulas[type](normalizedTime);\n            }\n\n            //If it's a spline, use the `spline` function and apply the\n            //2 additional `type` array values as the spline's start and\n            //end points\n            else {\n                //curve = tweenFunction.spline(n, type[1], 0, 1, type[2]);\n                curvedTime = _this5.easingFormulas.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n              }\n\n            //Apply the Bezier curve to the sprite's position\n            sprite.x = _this5.easingFormulas.cubicBezier(curvedTime, p[0][0], p[1][0], p[2][0], p[3][0]);\n            sprite.y = _this5.easingFormulas.cubicBezier(curvedTime, p[0][1], p[1][1], p[2][1], p[3][1]);\n\n            //Add one to the `elapsedFrames`\n            o.frameCounter += 1;\n          }\n\n          //When the tween has finished playing, run the end tasks\n          else {\n              //sprite[property] = o.endValue;\n              o.end();\n            }\n        }\n      };\n\n      //The `end` method will be called when the tween is finished\n      o.end = function () {\n\n        //Set `playing` to `false`\n        o.playing = false;\n\n        //Call the tween's `onComplete` method, if it's been\n        //assigned\n        if (o.onComplete) o.onComplete();\n\n        //Remove the tween from the global `tweens` array\n        _this5.globalTweens.splice(_this5.globalTweens.indexOf(o), 1);\n\n        //If the tween's `yoyo` property is `true`, reverse the array and\n        //use it to create a new tween\n        if (yoyo) {\n          _this5.wait(delayBeforeRepeat).then(function () {\n            o.pointsArray = o.pointsArray.reverse();\n            o.start(o.pointsArray);\n          });\n        }\n      };\n\n      //Pause and play methods\n      o.pause = function () {\n        o.playing = false;\n      };\n      o.play = function () {\n        o.playing = true;\n      };\n\n      //Return the tween object\n      return o;\n    }\n  }, {\n    key: \"walkPath\",\n    value: function walkPath(sprite, //The sprite\n    originalPathArray) //Delay, in milliseconds, between sections\n    {\n      var totalFrames = arguments.length <= 2 || arguments[2] === undefined ? 300 : arguments[2];\n      var type = arguments.length <= 3 || arguments[3] === undefined ? \"smoothstep\" : arguments[3];\n      var loop = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n      var _this6 = this;\n\n      var yoyo = arguments.length <= 5 || arguments[5] === undefined ? false : arguments[5];\n      var delayBetweenSections = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n\n      //Clone the path array so that any possible references to sprite\n      //properties are converted into ordinary numbers\n      var pathArray = JSON.parse(JSON.stringify(originalPathArray));\n\n      //Figure out the duration, in frames, of each path section by\n      //dividing the `totalFrames` by the length of the `pathArray`\n      var frames = totalFrames / pathArray.length;\n\n      //Set the current point to 0, which will be the first waypoint\n      var currentPoint = 0;\n\n      //The `makePath` function creates a single tween between two points and\n      //then schedules the next path to be made after it\n      var makePath = function makePath(currentPoint) {\n\n        //Use the `makeTween` function to tween the sprite's\n        //x and y position\n        var tween = _this6.makeTween([\n\n        //Create the x axis tween between the first x value in the\n        //current point and the x value in the following point\n        [sprite, \"x\", pathArray[currentPoint][0], pathArray[currentPoint + 1][0], frames, type],\n\n        //Create the y axis tween in the same way\n        [sprite, \"y\", pathArray[currentPoint][1], pathArray[currentPoint + 1][1], frames, type]]);\n\n        //When the tween is complete, advance the `currentPoint` by one.\n        //Add an optional delay between path segments, and then make the\n        //next connecting path\n        tween.onComplete = function () {\n\n          //Advance to the next point\n          currentPoint += 1;\n\n          //If the sprite hasn't reached the end of the\n          //path, tween the sprite to the next point\n          if (currentPoint < pathArray.length - 1) {\n            _this6.wait(delayBetweenSections).then(function () {\n              tween = makePath(currentPoint);\n            });\n          }\n\n          //If we've reached the end of the path, optionally\n          //loop and yoyo it\n          else {\n\n              //Reverse the path if `loop` is `true`\n              if (loop) {\n\n                //Reverse the array if `yoyo` is `true`\n                if (yoyo) pathArray.reverse();\n\n                //Optionally wait before restarting\n                _this6.wait(delayBetweenSections).then(function () {\n\n                  //Reset the `currentPoint` to 0 so that we can\n                  //restart at the first point\n                  currentPoint = 0;\n\n                  //Set the sprite to the first point\n                  sprite.x = pathArray[0][0];\n                  sprite.y = pathArray[0][1];\n\n                  //Make the first new path\n                  tween = makePath(currentPoint);\n\n                  //... and so it continues!\n                });\n              }\n            }\n        };\n\n        //Return the path tween to the main function\n        return tween;\n      };\n\n      //Make the first path using the internal `makePath` function (below)\n      var tween = makePath(currentPoint);\n\n      //Pass the tween back to the main program\n      return tween;\n    }\n  }, {\n    key: \"walkCurve\",\n    value: function walkCurve(sprite, //The sprite\n    pathArray) //Delay, in milliseconds, between sections\n    {\n      var totalFrames = arguments.length <= 2 || arguments[2] === undefined ? 300 : arguments[2];\n      var type = arguments.length <= 3 || arguments[3] === undefined ? \"smoothstep\" : arguments[3];\n      var loop = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n\n      var _this7 = this;\n\n      var yoyo = arguments.length <= 5 || arguments[5] === undefined ? false : arguments[5];\n      var delayBeforeContinue = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n\n      //Divide the `totalFrames` into sections for each part of the path\n      var frames = totalFrames / pathArray.length;\n\n      //Set the current curve to 0, which will be the first one\n      var currentCurve = 0;\n\n      //The `makePath` function\n      var makePath = function makePath(currentCurve) {\n\n        //Use the custom `followCurve` function to make\n        //a sprite follow a curve\n        var tween = _this7.followCurve(sprite, pathArray[currentCurve], frames, type);\n\n        //When the tween is complete, advance the `currentCurve` by one.\n        //Add an optional delay between path segments, and then make the\n        //next path\n        tween.onComplete = function () {\n          currentCurve += 1;\n          if (currentCurve < pathArray.length) {\n            _this7.wait(delayBeforeContinue).then(function () {\n              tween = makePath(currentCurve);\n            });\n          }\n\n          //If we've reached the end of the path, optionally\n          //loop and reverse it\n          else {\n              if (loop) {\n                if (yoyo) {\n\n                  //Reverse order of the curves in the `pathArray`\n                  pathArray.reverse();\n\n                  //Reverse the order of the points in each curve\n                  pathArray.forEach(function (curveArray) {\n                    return curveArray.reverse();\n                  });\n                }\n\n                //After an optional delay, reset the sprite to the\n                //beginning of the path and make the next new path\n                _this7.wait(delayBeforeContinue).then(function () {\n                  currentCurve = 0;\n                  sprite.x = pathArray[0][0];\n                  sprite.y = pathArray[0][1];\n                  tween = makePath(currentCurve);\n                });\n              }\n            }\n        };\n\n        //Return the path tween to the main function\n        return tween;\n      };\n\n      //Make the first path\n      var tween = makePath(currentCurve);\n\n      //Pass the tween back to the main program\n      return tween;\n    }\n\n    //4. Utilities\n\n    /*\n    The `wait` method lets you set up a timed sequence of events\n       wait(1000)\n        .then(() => console.log(\"One\"))\n        .then(() => wait(1000))\n        .then(() => console.log(\"Two\"))\n        .then(() => wait(1000))\n        .then(() => console.log(\"Three\"))\n     */\n\n  }, {\n    key: \"wait\",\n    value: function wait() {\n      var duration = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n      return new Promise(function (resolve, reject) {\n        setTimeout(resolve, duration);\n      });\n    }\n\n    //A utility to remove tweens from the game\n\n  }, {\n    key: \"removeTween\",\n    value: function removeTween(tweenObject) {\n      var _this8 = this;\n\n      //Remove the tween if `tweenObject` doesn't have any nested\n      //tween objects\n      if (!tweenObject.tweens) {\n        tweenObject.pause();\n        this.globalTweens.splice(this.globalTweens.indexOf(tweenObject), 1);\n\n        //Otherwise, remove the nested tween objects\n      } else {\n          tweenObject.pause();\n          tweenObject.tweens.forEach(function (element) {\n            _this8.globalTweens.splice(_this8.globalTweens.indexOf(element), 1);\n          });\n        }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n\n      //Update all the tween objects in the `globalTweens` array\n      if (this.globalTweens.length > 0) {\n        for (var i = this.globalTweens.length - 1; i >= 0; i--) {\n          var tween = this.globalTweens[i];\n          if (tween) tween.update();\n        }\n      }\n    }\n  }]);\n\n  return Charm;\n})();\n//# sourceMappingURL=charm.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Tink = (function () {\n  function Tink(PIXI, element) {\n    var scale = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n    _classCallCheck(this, Tink);\n\n    console.log(element);\n    //Add element and scale properties\n    this.element = element;\n    this.scale = scale;\n\n    //An array to store all the draggable sprites\n    this.draggableSprites = [];\n\n    //An array to store all the pointer objects\n    //(there will usually just be one)\n    this.pointers = [];\n\n    //An array to store all the buttons and button-like\n    //interactive sprites\n    this.buttons = [];\n\n    //A local PIXI reference\n    this.PIXI = PIXI;\n\n    //Aliases for Pixi objects\n    this.TextureCache = this.PIXI.utils.TextureCache;\n    this.MovieClip = this.PIXI.extras.MovieClip;\n    this.Texture = this.PIXI.Texture;\n  }\n\n  //`makeDraggable` lets you make a drag-and-drop sprite by pushing it\n  //into the `draggableSprites` array\n\n  _createClass(Tink, [{\n    key: \"makeDraggable\",\n    value: function makeDraggable() {\n      var _this = this;\n\n      for (var _len = arguments.length, sprites = Array(_len), _key = 0; _key < _len; _key++) {\n        sprites[_key] = arguments[_key];\n      }\n\n      //If the first argument isn't an array of sprites...\n      if (!(sprites[0] instanceof Array)) {\n        sprites.forEach(function (sprite) {\n          _this.draggableSprites.push(sprite);\n\n          //If the sprite's `draggable` property hasn't already been defined by\n          //another library, like Hexi, define it\n          if (sprite.draggable === undefined) {\n            sprite.draggable = true;\n            sprite._localDraggableAllocation = true;\n          }\n        });\n      }\n\n      //If the first argument is an array of sprites...\n      else {\n          var spritesArray = sprites[0];\n          if (spritesArray.length > 0) {\n            for (var i = spritesArray.length - 1; i >= 0; i--) {\n              var sprite = spritesArray[i];\n              this.draggableSprites.push(sprite);\n\n              //If the sprite's `draggable` property hasn't already been defined by\n              //another library, like Hexi, define it\n              if (sprite.draggable === undefined) {\n                sprite.draggable = true;\n                sprite._localDraggableAllocation = true;\n              }\n            }\n          }\n        }\n    }\n\n    //`makeUndraggable` removes the sprite from the `draggableSprites`\n    //array\n\n  }, {\n    key: \"makeUndraggable\",\n    value: function makeUndraggable() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, sprites = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        sprites[_key2] = arguments[_key2];\n      }\n\n      //If the first argument isn't an array of sprites...\n      if (!(sprites[0] instanceof Array)) {\n        sprites.forEach(function (sprite) {\n          _this2.draggableSprites.splice(_this2.draggableSprites.indexOf(sprite), 1);\n          if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n        });\n      }\n\n      //If the first argument is an array of sprites\n      else {\n          var spritesArray = sprites[0];\n          if (spritesArray.length > 0) {\n            for (var i = spritesArray.length - 1; i >= 0; i--) {\n              var sprite = spritesArray[i];\n              this.draggableSprites.splice(this.draggableSprites.indexOf(sprite), 1);\n              if (sprite._localDraggableAllocation === true) sprite.draggable = false;\n            }\n          }\n        }\n    }\n  }, {\n    key: \"makePointer\",\n    value: function makePointer() {\n      var element = arguments.length <= 0 || arguments[0] === undefined ? this.element : arguments[0];\n      var scale = arguments.length <= 1 || arguments[1] === undefined ? this.scale : arguments[1];\n\n      //Get a reference to Tink's global `draggableSprites` array\n      var draggableSprites = this.draggableSprites;\n\n      //Get a reference to Tink's `addGlobalPositionProperties` method\n      var addGlobalPositionProperties = this.addGlobalPositionProperties;\n\n      //The pointer object will be returned by this function\n      var pointer = {\n        element: element,\n        _scale: scale,\n\n        //Private x and y properties\n        _x: 0,\n        _y: 0,\n\n        //Width and height\n        width: 1,\n        height: 1,\n\n        //The public x and y properties are divided by the scale. If the\n        //HTML element that the pointer is sensitive to (like the canvas)\n        //is scaled up or down, you can change the `scale` value to\n        //correct the pointer's position values\n        get x() {\n          return this._x / this.scale;\n        },\n        get y() {\n          return this._y / this.scale;\n        },\n\n        //Add `centerX` and `centerY` getters so that we\n        //can use the pointer's coordinates with easing\n        //and collision functions\n        get centerX() {\n          return this.x;\n        },\n        get centerY() {\n          return this.y;\n        },\n\n        //`position` returns an object with x and y properties that\n        //contain the pointer's position\n        get position() {\n          return {\n            x: this.x,\n            y: this.y\n          };\n        },\n\n        get scale() {\n          return this._scale;\n        },\n        set scale(value) {\n          this._scale = value;\n        },\n\n        //Add a `cursor` getter/setter to change the pointer's cursor\n        //style. Values can be \"pointer\" (for a hand icon) or \"auto\" for\n        //an ordinary arrow icon.\n        get cursor() {\n          return this.element.style.cursor;\n        },\n        set cursor(value) {\n          this.element.style.cursor = value;\n        },\n\n        //Booleans to track the pointer state\n        isDown: false,\n        isUp: true,\n        tapped: false,\n\n        //Properties to help measure the time between up and down states\n        downTime: 0,\n        elapsedTime: 0,\n\n        //Optional `press`,`release` and `tap` methods\n        press: undefined,\n        release: undefined,\n        tap: undefined,\n\n        //A `dragSprite` property to help with drag and drop\n        dragSprite: null,\n\n        //The drag offsets to help drag sprites\n        dragOffsetX: 0,\n        dragOffsetY: 0,\n\n        //A property to check whether or not the pointer\n        //is visible\n        _visible: true,\n        get visible() {\n          return this._visible;\n        },\n        set visible(value) {\n          if (value === true) {\n            this.cursor = \"auto\";\n          } else {\n            this.cursor = \"none\";\n          }\n          this._visible = value;\n        },\n\n        //The pointer's mouse `moveHandler`\n        moveHandler: function moveHandler(event) {\n\n          //Get the element that's firing the event\n          var element = event.target;\n\n          //Find the pointer’s x and y position (for mouse).\n          //Subtract the element's top and left offset from the browser window\n          this._x = event.pageX - element.offsetLeft;\n          this._y = event.pageY - element.offsetTop;\n\n          //Prevent the event's default behavior\n          event.preventDefault();\n        },\n\n        //The pointer's `touchmoveHandler`\n        touchmoveHandler: function touchmoveHandler(event) {\n          var element = event.target;\n\n          //Find the touch point's x and y position\n          this._x = event.targetTouches[0].pageX - element.offsetLeft;\n          this._y = event.targetTouches[0].pageY - element.offsetTop;\n          event.preventDefault();\n        },\n\n        //The pointer's `downHandler`\n        downHandler: function downHandler(event) {\n\n          //Set the down states\n          this.isDown = true;\n          this.isUp = false;\n          this.tapped = false;\n\n          //Capture the current time\n          this.downTime = Date.now();\n\n          //Call the `press` method if it's been assigned\n          if (this.press) this.press();\n          event.preventDefault();\n        },\n\n        //The pointer's `touchstartHandler`\n        touchstartHandler: function touchstartHandler(event) {\n          var element = event.target;\n\n          //Find the touch point's x and y position\n          this._x = event.targetTouches[0].pageX - element.offsetLeft;\n          this._y = event.targetTouches[0].pageY - element.offsetTop;\n\n          //Set the down states\n          this.isDown = true;\n          this.isUp = false;\n          this.tapped = false;\n\n          //Capture the current time\n          this.downTime = Date.now();\n\n          //Call the `press` method if it's been assigned\n          if (this.press) this.press();\n          event.preventDefault();\n        },\n\n        //The pointer's `upHandler`\n        upHandler: function upHandler(event) {\n\n          //Figure out how much time the pointer has been down\n          this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n          //If it's less than 200 milliseconds, it must be a tap or click\n          if (this.elapsedTime <= 200 && this.tapped === false) {\n            this.tapped = true;\n\n            //Call the `tap` method if it's been assigned\n            if (this.tap) this.tap();\n          }\n          this.isUp = true;\n          this.isDown = false;\n\n          //Call the `release` method if it's been assigned\n          if (this.release) this.release();\n          event.preventDefault();\n        },\n\n        //The pointer's `touchendHandler`\n        touchendHandler: function touchendHandler(event) {\n\n          //Figure out how much time the pointer has been down\n          this.elapsedTime = Math.abs(this.downTime - Date.now());\n\n          //If it's less than 200 milliseconds, it must be a tap or click\n          if (this.elapsedTime <= 200 && this.tapped === false) {\n            this.tapped = true;\n\n            //Call the `tap` method if it's been assigned\n            if (this.tap) this.tap();\n          }\n          this.isUp = true;\n          this.isDown = false;\n\n          //Call the `release` method if it's been assigned\n          if (this.release) this.release();\n          event.preventDefault();\n        },\n\n        //`hitTestSprite` figures out if the pointer is touching a sprite\n        hitTestSprite: function hitTestSprite(sprite) {\n\n          //Add global `gx` and `gy` properties to the sprite if they\n          //don't already exist\n          addGlobalPositionProperties(sprite);\n\n          //The `hit` variable will become `true` if the pointer is\n          //touching the sprite and remain `false` if it isn't\n          var hit = false;\n\n          //Find out the sprite's offset from its anchor point\n          var xAnchorOffset = undefined,\n              yAnchorOffset = undefined;\n          if (sprite.anchor !== undefined) {\n            xAnchorOffset = sprite.width * sprite.anchor.x;\n            yAnchorOffset = sprite.height * sprite.anchor.y;\n          } else {\n            xAnchorOffset = 0;\n            yAnchorOffset = 0;\n          }\n\n          //Is the sprite rectangular?\n          if (!sprite.circular) {\n\n            //Get the position of the sprite's edges using global\n            //coordinates\n            var left = sprite.gx - xAnchorOffset,\n                right = sprite.gx + sprite.width - xAnchorOffset,\n                top = sprite.gy - yAnchorOffset,\n                bottom = sprite.gy + sprite.height - yAnchorOffset;\n\n            //Find out if the pointer is intersecting the rectangle.\n            //`hit` will become `true` if the pointer is inside the\n            //sprite's area\n            hit = this.x > left && this.x < right && this.y > top && this.y < bottom;\n          }\n\n          //Is the sprite circular?\n          else {\n              //Find the distance between the pointer and the\n              //center of the circle\n              var vx = this.x - (sprite.gx + sprite.width / 2 - xAnchorOffset),\n                  vy = this.y - (sprite.gy + sprite.width / 2 - yAnchorOffset),\n                  distance = Math.sqrt(vx * vx + vy * vy);\n\n              //The pointer is intersecting the circle if the\n              //distance is less than the circle's radius\n              hit = distance < sprite.width / 2;\n            }\n          //Check the value of `hit`\n          return hit;\n        }\n      };\n\n      //Bind the events to the handlers\n      //Mouse events\n      element.addEventListener(\"mousemove\", pointer.moveHandler.bind(pointer), false);\n      element.addEventListener(\"mousedown\", pointer.downHandler.bind(pointer), false);\n\n      //Add the `mouseup` event to the `window` to\n      //catch a mouse button release outside of the canvas area\n      window.addEventListener(\"mouseup\", pointer.upHandler.bind(pointer), false);\n\n      //Touch events\n      element.addEventListener(\"touchmove\", pointer.touchmoveHandler.bind(pointer), false);\n      element.addEventListener(\"touchstart\", pointer.touchstartHandler.bind(pointer), false);\n\n      //Add the `touchend` event to the `window` object to\n      //catch a mouse button release outside of the canvas area\n      window.addEventListener(\"touchend\", pointer.touchendHandler.bind(pointer), false);\n\n      //Disable the default pan and zoom actions on the `canvas`\n      element.style.touchAction = \"none\";\n\n      //Add the pointer to Tink's global `pointers` array\n      this.pointers.push(pointer);\n\n      //Return the pointer\n      return pointer;\n    }\n\n    //Many of Tink's objects, like pointers, use collision\n    //detection using the sprites' global x and y positions. To make\n    //this easier, new `gx` and `gy` properties are added to sprites\n    //that reference Pixi sprites' `getGlobalPosition()` values.\n\n  }, {\n    key: \"addGlobalPositionProperties\",\n    value: function addGlobalPositionProperties(sprite) {\n      if (sprite.gx === undefined) {\n        Object.defineProperty(sprite, \"gx\", {\n          get: function get() {\n            return sprite.getGlobalPosition().x;\n          }\n        });\n      }\n\n      if (sprite.gy === undefined) {\n        Object.defineProperty(sprite, \"gy\", {\n          get: function get() {\n            return sprite.getGlobalPosition().y;\n          }\n        });\n      }\n    }\n\n    //A method that implments drag-and-drop functionality\n    //for each pointer\n\n  }, {\n    key: \"updateDragAndDrop\",\n    value: function updateDragAndDrop(draggableSprites) {\n\n      //Create a pointer if one doesn't already exist\n      if (this.pointers.length === 0) {\n        this.makePointer(this.element, this.scale);\n      }\n\n      //Loop through all the pointers in Tink's global `pointers` array\n      //(there will usually just be one, but you never know)\n      this.pointers.forEach(function (pointer) {\n\n        //Check whether the pointer is pressed down\n        if (pointer.isDown) {\n\n          //You need to capture the co-ordinates at which the pointer was\n          //pressed down and find out if it's touching a sprite\n\n          //Only run pointer.code if the pointer isn't already dragging\n          //sprite\n          if (pointer.dragSprite === null) {\n\n            //Loop through the `draggableSprites` in reverse to start searching at the bottom of the stack\n            for (var i = draggableSprites.length - 1; i > -1; i--) {\n\n              //Get a reference to the current sprite\n              var sprite = draggableSprites[i];\n\n              //Check for a collision with the pointer using `hitTestSprite`\n              if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n\n                //Calculate the difference between the pointer's\n                //position and the sprite's position\n                pointer.dragOffsetX = pointer.x - sprite.gx;\n                pointer.dragOffsetY = pointer.y - sprite.gy;\n\n                //Set the sprite as the pointer's `dragSprite` property\n                pointer.dragSprite = sprite;\n\n                //The next two lines re-order the `sprites` array so that the\n                //selected sprite is displayed above all the others.\n                //First, splice the sprite out of its current position in\n                //its parent's `children` array\n                var children = sprite.parent.children;\n                children.splice(children.indexOf(sprite), 1);\n\n                //Next, push the `dragSprite` to the end of its `children` array so that it's\n                //displayed last, above all the other sprites\n                children.push(sprite);\n\n                //Reorganize the `draggableSpites` array in the same way\n                draggableSprites.splice(draggableSprites.indexOf(sprite), 1);\n                draggableSprites.push(sprite);\n\n                //Break the loop, because we only need to drag the topmost sprite\n                break;\n              }\n            }\n          }\n\n          //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n          //position, with the calculated offset\n          else {\n              pointer.dragSprite.x = pointer.x - pointer.dragOffsetX;\n              pointer.dragSprite.y = pointer.y - pointer.dragOffsetY;\n            }\n        }\n\n        //If the pointer is up, drop the `dragSprite` by setting it to `null`\n        if (pointer.isUp) {\n          pointer.dragSprite = null;\n        }\n\n        //Change the mouse arrow pointer to a hand if it's over a\n        //draggable sprite\n        draggableSprites.some(function (sprite) {\n          if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n            if (pointer.visible) pointer.cursor = \"pointer\";\n            return true;\n          } else {\n            if (pointer.visible) pointer.cursor = \"auto\";\n            return false;\n          }\n        });\n      });\n    }\n  }, {\n    key: \"makeInteractive\",\n    value: function makeInteractive(o) {\n\n      //The `press`,`release`, `over`, `out` and `tap` methods. They're `undefined`\n      //for now, but they can be defined in the game program\n      o.press = o.press || undefined;\n      o.release = o.release || undefined;\n      o.over = o.over || undefined;\n      o.out = o.out || undefined;\n      o.tap = o.tap || undefined;\n\n      //The `state` property tells you the button's\n      //current state. Set its initial state to \"up\"\n      o.state = \"up\";\n\n      //The `action` property tells you whether its being pressed or\n      //released\n      o.action = \"\";\n\n      //The `pressed` and `hoverOver` Booleans are mainly for internal\n      //use in this code to help figure out the correct state.\n      //`pressed` is a Boolean that helps track whether or not\n      //the sprite has been pressed down\n      o.pressed = false;\n\n      //`hoverOver` is a Boolean which checks whether the pointer\n      //has hovered over the sprite\n      o.hoverOver = false;\n\n      //tinkType is a string that will be set to \"button\" if the\n      //user creates an object using the `button` function\n      o.tinkType = \"\";\n\n      //Set `enabled` to true to allow for interactivity\n      //Set `enabled` to false to disable interactivity\n      o.enabled = true;\n\n      //Add the sprite to the global `buttons` array so that it can\n      //be updated each frame in the `updateButtons method\n      this.buttons.push(o);\n    }\n\n    //The `updateButtons` method will be called each frame\n    //inside the game loop. It updates all the button-like sprites\n\n  }, {\n    key: \"updateButtons\",\n    value: function updateButtons() {\n      var _this3 = this;\n\n      //Create a pointer if one doesn't already exist\n      if (this.pointers.length === 0) {\n        this.makePointer(this.element, this.scale);\n      }\n\n      //Loop through all the button-like sprites that were created\n      //using the `makeInteractive` method\n      this.buttons.forEach(function (o) {\n\n        //Only do this if the interactive object is enabled\n        if (o.enabled) {\n\n          //Loop through all of Tink's pointers (there will usually\n          //just be one)\n          _this3.pointers.forEach(function (pointer) {\n\n            //Figure out if the pointer is touching the sprite\n            var hit = pointer.hitTestSprite(o);\n\n            //1. Figure out the current state\n            if (pointer.isUp) {\n\n              //Up state\n              o.state = \"up\";\n\n              //Show the first image state frame, if this is a `Button` sprite\n              if (o.tinkType === \"button\") o.gotoAndStop(0);\n            }\n\n            //If the pointer is touching the sprite, figure out\n            //if the over or down state should be displayed\n            if (hit) {\n\n              //Over state\n              o.state = \"over\";\n\n              //Show the second image state frame if this sprite has\n              //3 frames and it's a `Button` sprite\n              if (o.totalFrames && o.totalFrames === 3 && o.tinkType === \"button\") {\n                o.gotoAndStop(1);\n              }\n\n              //Down state\n              if (pointer.isDown) {\n                o.state = \"down\";\n\n                //Show the third frame if this sprite is a `Button` sprite and it\n                //has only three frames, or show the second frame if it\n                //only has two frames\n                if (o.tinkType === \"button\") {\n                  if (o.totalFrames === 3) {\n                    o.gotoAndStop(2);\n                  } else {\n                    o.gotoAndStop(1);\n                  }\n                }\n              }\n\n              //Change the pointer icon to a hand\n              if (pointer.visible) pointer.cursor = \"pointer\";\n            } else {\n              //Turn the pointer to an ordinary arrow icon if the\n              //pointer isn't touching a sprite\n              if (pointer.visible) pointer.cursor = \"auto\";\n            }\n\n            //Perform the correct interactive action\n\n            //a. Run the `press` method if the sprite state is \"down\" and\n            //the sprite hasn't already been pressed\n            if (o.state === \"down\") {\n              if (!o.pressed) {\n                if (o.press) o.press();\n                o.pressed = true;\n                o.action = \"pressed\";\n              }\n            }\n\n            //b. Run the `release` method if the sprite state is \"over\" and\n            //the sprite has been pressed\n            if (o.state === \"over\") {\n              if (o.pressed) {\n                if (o.release) o.release();\n                o.pressed = false;\n                o.action = \"released\";\n                //If the pointer was tapped and the user assigned a `tap`\n                //method, call the `tap` method\n                if (pointer.tapped && o.tap) o.tap();\n              }\n\n              //Run the `over` method if it has been assigned\n              if (!o.hoverOver) {\n                if (o.over) o.over();\n                o.hoverOver = true;\n              }\n            }\n\n            //c. Check whether the pointer has been released outside\n            //the sprite's area. If the button state is \"up\" and it's\n            //already been pressed, then run the `release` method.\n            if (o.state === \"up\") {\n              if (o.pressed) {\n                if (o.release) o.release();\n                o.pressed = false;\n                o.action = \"released\";\n              }\n\n              //Run the `out` method if it has been assigned\n              if (o.hoverOver) {\n                if (o.out) o.out();\n                o.hoverOver = false;\n              }\n            }\n          });\n        }\n      });\n    }\n\n    //A function that creates a sprite with 3 frames that\n    //represent the button states: up, over and down\n\n  }, {\n    key: \"button\",\n    value: function button(source) {\n      var x = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var y = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n      //The sprite object that will be returned\n      var o = undefined;\n\n      //Is it an array of frame ids or textures?\n      if (typeof source[0] === \"string\") {\n\n        //They're strings, but are they pre-existing texture or\n        //paths to image files?\n        //Check to see if the first element matches a texture in the\n        //cache\n        if (this.TextureCache[source[0]]) {\n\n          //It does, so it's an array of frame ids\n          o = this.MovieClip.fromFrames(source);\n        } else {\n\n          //It's not already in the cache, so let's load it\n          o = this.MovieClip.fromImages(source);\n        }\n      }\n\n      //If the `source` isn't an array of strings, check whether\n      //it's an array of textures\n      else if (source[0] instanceof this.Texture) {\n\n          //Yes, it's an array of textures.\n          //Use them to make a MovieClip o\n          o = new this.MovieClip(source);\n        }\n\n      //Add interactive properties to the button\n      this.makeInteractive(o);\n\n      //Set the `tinkType` to \"button\"\n      o.tinkType = \"button\";\n\n      //Position the button\n      o.x = x;\n      o.y = y;\n\n      //Return the new button sprite\n      return o;\n    }\n\n    //Run the `udpate` function in your game loop\n    //to update all of Tink's interactive objects\n\n  }, {\n    key: \"update\",\n    value: function update() {\n\n      //Update the drag and drop system\n      if (this.draggableSprites.length !== 0) this.updateDragAndDrop(this.draggableSprites);\n\n      //Update the buttons and button-like interactive sprites\n      if (this.buttons.length !== 0) this.updateButtons();\n    }\n\n    /*\n    `keyboard` is a method that listens for and captures keyboard events. It's really\n    just a convenient wrapper function for HTML `keyup` and `keydown` events so that you can keep your application code clutter-free and easier to write and read.\n     Here's how to use the `keyboard` method. Create a new keyboard object like this:\n    ```js\n    let keyObject = keyboard(asciiKeyCodeNumber);\n    ```\n    It's one argument is the ASCII key code number of the keyboard key\n    that you want to listen for. [Here's a list of ASCII key codes you can\n    use](http://www.asciitable.com).\n    Then assign `press` and `release` methods to the keyboard object like this:\n    ```js\n    keyObject.press = () => {\n      //key object pressed\n    };\n    keyObject.release = () => {\n      //key object released\n    };\n    ```\n    Keyboard objects also have `isDown` and `isUp` Boolean properties that you can use to check the state of each key. \n    */\n\n  }, {\n    key: \"keyboard\",\n    value: function keyboard(keyCode) {\n      var key = {};\n      key.code = keyCode;\n      key.isDown = false;\n      key.isUp = true;\n      key.press = undefined;\n      key.release = undefined;\n\n      //The `downHandler`\n      key.downHandler = function (event) {\n        if (event.keyCode === key.code) {\n          if (key.isUp && key.press) key.press();\n          key.isDown = true;\n          key.isUp = false;\n        }\n        event.preventDefault();\n      };\n\n      //The `upHandler`\n      key.upHandler = function (event) {\n        if (event.keyCode === key.code) {\n          if (key.isDown && key.release) key.release();\n          key.isDown = false;\n          key.isUp = true;\n        }\n        event.preventDefault();\n      };\n\n      //Attach event listeners\n      window.addEventListener(\"keydown\", key.downHandler.bind(key), false);\n      window.addEventListener(\"keyup\", key.upHandler.bind(key), false);\n\n      //Return the key object\n      return key;\n    }\n\n    //`arrowControl` is a convenience method for updating a sprite's velocity\n    //for 4-way movement using the arrow directional keys. Supply it\n    //with the sprite you want to control and the speed per frame, in\n    //pixels, that you want to update the sprite's velocity\n\n  }, {\n    key: \"arrowControl\",\n    value: function arrowControl(sprite, speed) {\n\n      if (speed === undefined) {\n        throw new Error(\"Please supply the arrowControl method with the speed at which you want the sprite to move\");\n      }\n\n      var upArrow = this.keyboard(38),\n          rightArrow = this.keyboard(39),\n          downArrow = this.keyboard(40),\n          leftArrow = this.keyboard(37);\n\n      //Assign key `press` methods\n      leftArrow.press = function () {\n        //Change the sprite's velocity when the key is pressed\n        sprite.vx = -speed;\n        sprite.vy = 0;\n      };\n      leftArrow.release = function () {\n        //If the left arrow has been released, and the right arrow isn't down,\n        //and the sprite isn't moving vertically:\n        //Stop the sprite\n        if (!rightArrow.isDown && sprite.vy === 0) {\n          sprite.vx = 0;\n        }\n      };\n      upArrow.press = function () {\n        sprite.vy = -speed;\n        sprite.vx = 0;\n      };\n      upArrow.release = function () {\n        if (!downArrow.isDown && sprite.vx === 0) {\n          sprite.vy = 0;\n        }\n      };\n      rightArrow.press = function () {\n        sprite.vx = speed;\n        sprite.vy = 0;\n      };\n      rightArrow.release = function () {\n        if (!leftArrow.isDown && sprite.vy === 0) {\n          sprite.vx = 0;\n        }\n      };\n      downArrow.press = function () {\n        sprite.vy = speed;\n        sprite.vx = 0;\n      };\n      downArrow.release = function () {\n        if (!upArrow.isDown && sprite.vx === 0) {\n          sprite.vy = 0;\n        }\n      };\n    }\n  }]);\n\n  return Tink;\n})();\n//# sourceMappingURL=tink.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Dust = (function () {\n  function Dust() {\n    var renderingEngine = arguments[0] === undefined ? PIXI : arguments[0];\n\n    _classCallCheck(this, Dust);\n\n    if (renderingEngine === undefined) throw new Error(\"Please assign a rendering engine in the constructor before using pixiDust.js\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer) {\n      this.Container = renderingEngine.Container;\n      this.renderer = \"pixi\";\n    }\n\n    //The `particles` array stores all the particles you make\n    this.globalParticles = [];\n  }\n\n  _createClass(Dust, [{\n    key: \"randomFloat\",\n\n    //Random number functions\n    value: function randomFloat(min, max) {\n      return min + Math.random() * (max - min);\n    }\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n  }, {\n    key: \"create\",\n\n    //Use the create function to create new particle effects\n    value: function create() {\n      var x = arguments[0] === undefined ? 0 : arguments[0];\n      var y = arguments[1] === undefined ? 0 : arguments[1];\n      var spriteFunction = arguments[2] === undefined ? function () {\n        return console.log(\"Sprite creation function\");\n      } : arguments[2];\n      var container = arguments[3] === undefined ? function () {\n        return new _this.Container();\n      } : arguments[3];\n      var numberOfParticles = arguments[4] === undefined ? 20 : arguments[4];\n      var gravity = arguments[5] === undefined ? 0 : arguments[5];\n      var randomSpacing = arguments[6] === undefined ? true : arguments[6];\n      var minAngle = arguments[7] === undefined ? 0 : arguments[7];\n      var maxAngle = arguments[8] === undefined ? 6.28 : arguments[8];\n      var minSize = arguments[9] === undefined ? 4 : arguments[9];\n      var maxSize = arguments[10] === undefined ? 16 : arguments[10];\n      var minSpeed = arguments[11] === undefined ? 0.3 : arguments[11];\n      var maxSpeed = arguments[12] === undefined ? 3 : arguments[12];\n      var minScaleSpeed = arguments[13] === undefined ? 0.01 : arguments[13];\n      var maxScaleSpeed = arguments[14] === undefined ? 0.05 : arguments[14];\n      var minAlphaSpeed = arguments[15] === undefined ? 0.02 : arguments[15];\n      var maxAlphaSpeed = arguments[16] === undefined ? 0.02 : arguments[16];\n\n      var _this = this;\n\n      var minRotationSpeed = arguments[17] === undefined ? 0.01 : arguments[17];\n      var maxRotationSpeed = arguments[18] === undefined ? 0.03 : arguments[18];\n\n      //An array to store the curent batch of particles\n      var particles = [];\n\n      //Add the current `particles` array to the `globalParticles` array\n      this.globalParticles.push(particles);\n\n      //An array to store the angles\n      var angles = [];\n\n      //A variable to store the current particle's angle\n      var angle = undefined;\n\n      //Figure out by how many radians each particle should be separated\n      var spacing = (maxAngle - minAngle) / (numberOfParticles - 1);\n\n      //Create an angle value for each particle and push that //value into the `angles` array\n      for (var i = 0; i < numberOfParticles; i++) {\n\n        //If `randomSpacing` is `true`, give the particle any angle\n        //value between `minAngle` and `maxAngle`\n        if (randomSpacing) {\n          angle = this.randomFloat(minAngle, maxAngle);\n          angles.push(angle);\n        }\n\n        //If `randomSpacing` is `false`, space each particle evenly,\n        //starting with the `minAngle` and ending with the `maxAngle`\n        else {\n          if (angle === undefined) angle = minAngle;\n          angles.push(angle);\n          angle += spacing;\n        }\n      }\n\n      //A function to make particles\n      var makeParticle = function makeParticle(angle) {\n\n        //Create the particle using the supplied sprite function\n        var particle = spriteFunction();\n\n        //Display a random frame if the particle has more than 1 frame\n        if (particle.totalFrames > 0) {\n          particle.gotoAndStop(_this.randomInt(0, particle.totalFrames - 1));\n        }\n\n        //Set a random width and height\n        var size = _this.randomInt(minSize, maxSize);\n        particle.width = size;\n        particle.height = size;\n\n        //Set the particle's `anchor` to its center\n        particle.anchor.set(0.5, 0.5);\n\n        //Set the x and y position\n        particle.x = x;\n        particle.y = y;\n\n        //Set a random speed to change the scale, alpha and rotation\n        particle.scaleSpeed = _this.randomFloat(minScaleSpeed, maxScaleSpeed);\n        particle.alphaSpeed = _this.randomFloat(minAlphaSpeed, maxAlphaSpeed);\n        particle.rotationSpeed = _this.randomFloat(minRotationSpeed, maxRotationSpeed);\n\n        //Set a random velocity at which the particle should move\n        var speed = _this.randomFloat(minSpeed, maxSpeed);\n        particle.vx = speed * Math.cos(angle);\n        particle.vy = speed * Math.sin(angle);\n\n        //Push the particle into the `particles` array.\n        //The `particles` array needs to be updated by the game loop each frame particles.push(particle);\n        particles.push(particle);\n\n        //Add the particle to its parent container\n        container.addChild(particle);\n\n        //The particle's `updateParticle` method is called on each frame of the\n        //game loop\n        particle.updateParticle = function () {\n\n          //Add gravity\n          particle.vy += gravity;\n\n          //Move the particle\n          particle.x += particle.vx;\n          particle.y += particle.vy;\n\n          //Change the particle's `scale`\n          if (particle.scale.x - particle.scaleSpeed > 0) {\n            particle.scale.x -= particle.scaleSpeed;\n          }\n          if (particle.scale.y - particle.scaleSpeed > 0) {\n            particle.scale.y -= particle.scaleSpeed;\n          }\n\n          //Change the particle's rotation\n          particle.rotation += particle.rotationSpeed;\n\n          //Change the particle's `alpha`\n          particle.alpha -= particle.alphaSpeed;\n\n          //Remove the particle if its `alpha` reaches zero\n          if (particle.alpha <= 0) {\n            container.removeChild(particle);\n            particles.splice(particles.indexOf(particle), 1);\n          }\n        };\n      };\n\n      //Make a particle for each angle\n      angles.forEach(function (angle) {\n        return makeParticle(angle);\n      });\n\n      //Return the `particles` array back to the main program\n      return particles;\n    }\n  }, {\n    key: \"emitter\",\n\n    //A particle emitter\n    value: function emitter(interval, particleFunction) {\n      var emitter = {},\n          timerInterval = undefined;\n\n      emitter.playing = false;\n\n      function play() {\n        if (!emitter.playing) {\n          particleFunction();\n          timerInterval = setInterval(emitParticle.bind(this), interval);\n          emitter.playing = true;\n        }\n      }\n\n      function stop() {\n        if (emitter.playing) {\n          clearInterval(timerInterval);\n          emitter.playing = false;\n        }\n      }\n\n      function emitParticle() {\n        particleFunction();\n      }\n\n      emitter.play = play;\n      emitter.stop = stop;\n      return emitter;\n    }\n  }, {\n    key: \"update\",\n\n    //A function to update the particles in the game loop\n    value: function update() {\n\n      //Check so see if the `globalParticles` array contains any\n      //sub-arrays\n      if (this.globalParticles.length > 0) {\n\n        //If it does, Loop through the particle arrays in reverse\n        for (var i = this.globalParticles.length - 1; i >= 0; i--) {\n\n          //Get the current particle sub-array\n          var particles = this.globalParticles[i];\n\n          //Loop through the `particles` sub-array and update the\n          //all the particle sprites that it contains\n          if (particles.length > 0) {\n            for (var j = particles.length - 1; j >= 0; j--) {\n              var particle = particles[j];\n              particle.updateParticle();\n            }\n          }\n\n          //Remove the particle array from the `globalParticles` array if doesn't\n          //contain any more sprites\n          else {\n            this.globalParticles.splice(this.globalParticles.indexOf(particles), 1);\n          }\n        }\n      }\n    }\n  }]);\n\n  return Dust;\n})();\n//# sourceMappingURL=dust.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SpriteUtilities = (function () {\n  function SpriteUtilities() {\n    var renderingEngine = arguments.length <= 0 || arguments[0] === undefined ? PIXI : arguments[0];\n\n    _classCallCheck(this, SpriteUtilities);\n\n    if (renderingEngine === undefined) throw new Error(\"Please supply a reference to PIXI in the SpriteUtilities constructor before using spriteUtilities.js\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderer = \"pixi\";\n      this.Container = renderingEngine.Container;\n      this.ParticleContainer = renderingEngine.ParticleContainer;\n      this.TextureCache = renderingEngine.utils.TextureCache;\n      this.Texture = renderingEngine.Texture;\n      this.Rectangle = renderingEngine.Rectangle;\n      this.MovieClip = renderingEngine.extras.MovieClip;\n      this.BitmapText = renderingEngine.extras.BitmapText;\n      this.Sprite = renderingEngine.Sprite;\n      this.TilingSprite = renderingEngine.extras.TilingSprite;\n      this.Graphics = renderingEngine.Graphics;\n      this.Text = renderingEngine.Text;\n\n      //An array to store all the shaking sprites\n      this.shakingSprites = [];\n    }\n  }\n\n  _createClass(SpriteUtilities, [{\n    key: \"update\",\n    value: function update() {\n      if (this.shakingSprites.length > 0) {\n        for (var i = this.shakingSprites.length - 1; i >= 0; i--) {\n          var shakingSprite = this.shakingSprites[i];\n          if (shakingSprite.updateShake) shakingSprite.updateShake();\n        }\n      }\n    }\n  }, {\n    key: \"sprite\",\n    value: function sprite(source) {\n      var x = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var y = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n      var tiling = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n      var width = arguments[4];\n      var height = arguments[5];\n\n      var o = undefined,\n          texture = undefined;\n\n      //Create a sprite if the `source` is a string\n      if (typeof source === \"string\") {\n\n        //Access the texture in the cache if it's there\n        if (this.TextureCache[source]) {\n          texture = this.TextureCache[source];\n        }\n\n        //If it's not is the cache, load it from the source file\n        else {\n            texture = this.Texture.fromImage(source);\n          }\n\n        //If the texture was created, make the o\n        if (texture) {\n\n          //If `tiling` is `false`, make a regular `Sprite`\n          if (!tiling) {\n            o = new this.Sprite(texture);\n          }\n\n          //If `tiling` is `true` make a `TilingSprite`\n          else {\n              o = new this.TilingSprite(texture, width, height);\n            }\n        }\n        //But if the source still can't be found, alert the user\n        else {\n            throw new Error(source + \" cannot be found\");\n          }\n      }\n\n      //Create a o if the `source` is a texture\n      else if (source instanceof this.Texture) {\n          if (!tiling) {\n            o = new this.Sprite(source);\n          } else {\n            o = new this.TilingSprite(source, width, height);\n          }\n        }\n\n        //Create a `MovieClip` o if the `source` is an array\n        else if (source instanceof Array) {\n\n            //Is it an array of frame ids or textures?\n            if (typeof source[0] === \"string\") {\n\n              //They're strings, but are they pre-existing texture or\n              //paths to image files?\n              //Check to see if the first element matches a texture in the\n              //cache\n              if (this.TextureCache[source[0]]) {\n\n                //It does, so it's an array of frame ids\n                o = this.MovieClip.fromFrames(source);\n              } else {\n\n                //It's not already in the cache, so let's load it\n                o = this.MovieClip.fromImages(source);\n              }\n            }\n\n            //If the `source` isn't an array of strings, check whether\n            //it's an array of textures\n            else if (source[0] instanceof this.Texture) {\n\n                //Yes, it's an array of textures.\n                //Use them to make a MovieClip o\n                o = new this.MovieClip(source);\n              }\n          }\n\n      //If the sprite was successfully created, intialize it\n      if (o) {\n\n        //Position the sprite\n        o.x = x;\n        o.y = y;\n\n        //Set optional width and height\n        if (width) o.width = width;\n        if (height) o.height = height;\n\n        //If the sprite is a MovieClip, add a state player so that\n        //it's easier to control\n        if (o instanceof this.MovieClip) this.addStatePlayer(o);\n\n        //Assign the sprite\n        return o;\n      }\n    }\n  }, {\n    key: \"addStatePlayer\",\n    value: function addStatePlayer(sprite) {\n\n      var frameCounter = 0,\n          numberOfFrames = 0,\n          startFrame = 0,\n          endFrame = 0,\n          timerInterval = undefined;\n\n      //The `show` function (to display static states)\n      function show(frameNumber) {\n\n        //Reset any possible previous animations\n        reset();\n\n        //Find the new state on the sprite\n        sprite.gotoAndStop(frameNumber);\n      }\n\n      //The `stop` function stops the animation at the current frame\n      function stopAnimation() {\n        reset();\n        sprite.gotoAndStop(sprite.currentFrame);\n      }\n\n      //The `playSequence` function, to play a sequence of frames\n      function playAnimation(sequenceArray) {\n\n        //Reset any possible previous animations\n        reset();\n\n        //Figure out how many frames there are in the range\n        if (!sequenceArray) {\n          startFrame = 0;\n          endFrame = sprite.totalFrames - 1;\n        } else {\n          startFrame = sequenceArray[0];\n          endFrame = sequenceArray[1];\n        }\n\n        //Calculate the number of frames\n        numberOfFrames = endFrame - startFrame;\n\n        //Compensate for two edge cases:\n        //1. If the `startFrame` happens to be `0`\n        /*\n        if (startFrame === 0) {\n          numberOfFrames += 1;\n          frameCounter += 1;\n        }\n        */\n\n        //2. If only a two-frame sequence was provided\n        /*\n        if(numberOfFrames === 1) {\n          numberOfFrames = 2;\n          frameCounter += 1;\n        }  \n        */\n\n        //Calculate the frame rate. Set the default fps to 12\n        if (!sprite.fps) sprite.fps = 12;\n        var frameRate = 1000 / sprite.fps;\n\n        //Set the sprite to the starting frame\n        sprite.gotoAndStop(startFrame);\n\n        //Set the `frameCounter` to the first frame\n        frameCounter = 1;\n\n        //If the state isn't already `playing`, start it\n        if (!sprite.animating) {\n          timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n          sprite.animating = true;\n        }\n      }\n\n      //`advanceFrame` is called by `setInterval` to display the next frame\n      //in the sequence based on the `frameRate`. When the frame sequence\n      //reaches the end, it will either stop or loop\n      function advanceFrame() {\n\n        //Advance the frame if `frameCounter` is less than\n        //the state's total frames\n        if (frameCounter < numberOfFrames + 1) {\n\n          //Advance the frame\n          sprite.gotoAndStop(sprite.currentFrame + 1);\n\n          //Update the frame counter\n          frameCounter += 1;\n\n          //If we've reached the last frame and `loop`\n          //is `true`, then start from the first frame again\n        } else {\n            if (sprite.loop) {\n              sprite.gotoAndStop(startFrame);\n              frameCounter = 1;\n            }\n          }\n      }\n\n      function reset() {\n\n        //Reset `sprite.playing` to `false`, set the `frameCounter` to 0, //and clear the `timerInterval`\n        if (timerInterval !== undefined && sprite.animating === true) {\n          sprite.animating = false;\n          frameCounter = 0;\n          startFrame = 0;\n          endFrame = 0;\n          numberOfFrames = 0;\n          clearInterval(timerInterval);\n        }\n      }\n\n      //Add the `show`, `play`, `stop`, and `playSequence` methods to the sprite\n      sprite.show = show;\n      sprite.stopAnimation = stopAnimation;\n      sprite.playAnimation = playAnimation;\n    }\n\n    //`tilingSpirte` lets you quickly create Pixi tiling sprites\n\n  }, {\n    key: \"tilingSprite\",\n    value: function tilingSprite(source, width, height, x, y) {\n      if (width === undefined) {\n        throw new Error(\"Please define a width as your second argument for the tiling sprite\");\n      }\n      if (height === undefined) {\n        throw new Error(\"Please define a height as your third argument for the tiling sprite\");\n      }\n      var o = this.sprite(source, x, y, true, width, height);\n\n      //Add `tileX`, `tileY`, `tileScaleX` and `tileScaleY` properties\n      Object.defineProperties(o, {\n        \"tileX\": {\n          get: function get() {\n            return o.tilePosition.x;\n          },\n          set: function set(value) {\n            o.tilePosition.x = value;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"tileY\": {\n          get: function get() {\n            return o.tilePosition.y;\n          },\n          set: function set(value) {\n            o.tilePosition.y = value;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"tileScaleX\": {\n          get: function get() {\n            return o.tileScale.x;\n          },\n          set: function set(value) {\n            o.tileScale.x = value;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"tileScaleY\": {\n          get: function get() {\n            return o.tileScale.y;\n          },\n          set: function set(value) {\n            o.tileScale.y = value;\n          },\n\n          enumerable: true, configurable: true\n        }\n      });\n\n      return o;\n    }\n  }, {\n    key: \"filmstrip\",\n    value: function filmstrip(texture, frameWidth, frameHeight) {\n      var spacing = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n      //An array to store the x/y positions of the frames\n      var positions = [];\n\n      //Find the width and height of the texture\n      var textureWidth = this.TextureCache[texture].width,\n          textureHeight = this.TextureCache[texture].height;\n\n      //Find out how many columns and rows there are\n      var columns = textureWidth / frameWidth,\n          rows = textureHeight / frameHeight;\n\n      //Find the total number of frames\n      var numberOfFrames = columns * rows;\n\n      for (var i = 0; i < numberOfFrames; i++) {\n\n        //Find the correct row and column for each frame\n        //and figure out its x and y position\n        var x = i % columns * frameWidth,\n            y = Math.floor(i / columns) * frameHeight;\n\n        //Compensate for any optional spacing (padding) around the tiles if\n        //there is any. This bit of code accumlates the spacing offsets from the\n        //left side of the tileset and adds them to the current tile's position\n        if (spacing > 0) {\n          x += spacing + spacing * i % columns;\n          y += spacing + spacing * Math.floor(i / columns);\n        }\n\n        //Add the x and y value of each frame to the `positions` array\n        positions.push([x, y]);\n      }\n\n      //Return the frames\n      return this.frames(texture, positions, frameWidth, frameHeight);\n    }\n\n    //Make a texture from a frame in another texture or image\n\n  }, {\n    key: \"frame\",\n    value: function frame(source, x, y, width, height) {\n\n      var texture = undefined,\n          imageFrame = undefined;\n\n      //If the source is a string, it's either a texture in the\n      //cache or an image file\n      if (typeof source === \"string\") {\n        if (this.TextureCache[source]) {\n          texture = new this.Texture(this.TextureCache[source]);\n        }\n      }\n\n      //If the `source` is a texture,  use it\n      else if (source instanceof this.Texture) {\n          texture = new this.Texture(source);\n        }\n      if (!texture) {\n        throw new Error(\"Please load the \" + source + \" texture into the cache.\");\n      } else {\n\n        //Make a rectangle the size of the sub-image\n        imageFrame = new this.Rectangle(x, y, width, height);\n        texture.frame = imageFrame;\n        return texture;\n      }\n    }\n\n    //Make an array of textures from a 2D array of frame x and y coordinates in\n    //texture\n\n  }, {\n    key: \"frames\",\n    value: function frames(source, coordinates, frameWidth, frameHeight) {\n      var _this = this;\n\n      var baseTexture = undefined,\n          textures = undefined;\n\n      //If the source is a string, it's either a texture in the\n      //cache or an image file\n      if (typeof source === \"string\") {\n        if (this.TextureCache[source]) {\n          baseTexture = new this.Texture(this.TextureCache[source]);\n        }\n      }\n      //If the `source` is a texture,  use it\n      else if (source instanceof this.Texture) {\n          baseTexture = new this.Texture(source);\n        }\n      if (!baseTexture) {\n        throw new Error(\"Please load the \" + source + \" texture into the cache.\");\n      } else {\n        var _textures = coordinates.map(function (position) {\n          var x = position[0],\n              y = position[1];\n          var imageFrame = new _this.Rectangle(x, y, frameWidth, frameHeight);\n          var frameTexture = new _this.Texture(baseTexture);\n          frameTexture.frame = imageFrame;\n          return frameTexture;\n        });\n        return _textures;\n      }\n    }\n  }, {\n    key: \"frameSeries\",\n    value: function frameSeries() {\n      var startNumber = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var endNumber = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n      var baseName = arguments.length <= 2 || arguments[2] === undefined ? \"\" : arguments[2];\n      var extension = arguments.length <= 3 || arguments[3] === undefined ? \"\" : arguments[3];\n\n      //Create an array to store the frame names\n      var frames = [];\n\n      for (var i = startNumber; i < endNumber + 1; i++) {\n        var frame = this.TextureCache[\"\" + (baseName + i + extension)];\n        frames.push(frame);\n      }\n      return frames;\n    }\n\n    /* Text creation */\n\n    //The`text` method is a quick way to create a Pixi Text sprite\n\n  }, {\n    key: \"text\",\n    value: function text() {\n      var content = arguments.length <= 0 || arguments[0] === undefined ? \"message\" : arguments[0];\n      var font = arguments.length <= 1 || arguments[1] === undefined ? \"16px sans\" : arguments[1];\n      var fillStyle = arguments.length <= 2 || arguments[2] === undefined ? \"red\" : arguments[2];\n      var x = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n      var y = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n\n      //Create a Pixi Sprite object\n      var message = new this.Text(content, { font: font, fill: fillStyle });\n      message.x = x;\n      message.y = y;\n\n      //Add a `_text` property with a getter/setter\n      message._content = content;\n      Object.defineProperty(message, \"content\", {\n        get: function get() {\n          return this._content;\n        },\n        set: function set(value) {\n          this._content = value;\n          this.text = value;\n        },\n\n        enumerable: true, configurable: true\n      });\n\n      //Return the text object\n      return message;\n    }\n\n    //The`bitmapText` method lets you create bitmap text\n\n  }, {\n    key: \"bitmapText\",\n    value: function bitmapText() {\n      var content = arguments.length <= 0 || arguments[0] === undefined ? \"message\" : arguments[0];\n      var font = arguments[1];\n      var align = arguments[2];\n      var tint = arguments[3];\n      var x = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n      var y = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n      //Create a Pixi Sprite object\n      var message = new this.BitmapText(content, { font: font, align: align, tint: tint });\n      message.x = x;\n      message.y = y;\n\n      //Add a `_text` property with a getter/setter\n      message._content = content;\n      Object.defineProperty(message, \"content\", {\n        get: function get() {\n          return this._content;\n        },\n        set: function set(value) {\n          this._content = value;\n          this.text = value;\n        },\n\n        enumerable: true, configurable: true\n      });\n\n      //Return the text object\n      return message;\n    }\n\n    /* Shapes and lines */\n\n    //Rectangle\n\n  }, {\n    key: \"rectangle\",\n    value: function rectangle() {\n      var width = arguments.length <= 0 || arguments[0] === undefined ? 32 : arguments[0];\n      var height = arguments.length <= 1 || arguments[1] === undefined ? 32 : arguments[1];\n      var fillStyle = arguments.length <= 2 || arguments[2] === undefined ? 0xFF3300 : arguments[2];\n      var strokeStyle = arguments.length <= 3 || arguments[3] === undefined ? 0x0033CC : arguments[3];\n      var lineWidth = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n      var x = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n      var y = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n\n      var o = new this.Graphics();\n      o._sprite = undefined;\n      o._width = width;\n      o._height = height;\n      o._fillStyle = this.color(fillStyle);\n      o._strokeStyle = this.color(strokeStyle);\n      o._lineWidth = lineWidth;\n\n      //Draw the rectangle\n      var draw = function draw(width, height, fillStyle, strokeStyle, lineWidth) {\n        o.clear();\n        o.beginFill(fillStyle);\n        if (lineWidth > 0) {\n          o.lineStyle(lineWidth, strokeStyle, 1);\n        }\n        o.drawRect(0, 0, width, height);\n        o.endFill();\n      };\n\n      //Draw the line and capture the sprite that the `draw` function\n      //returns\n      draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n      //Generate a texture from the rectangle\n      var texture = o.generateTexture();\n\n      //Use the texture to create a sprite\n      var sprite = new this.Sprite(texture);\n\n      //Position the sprite\n      sprite.x = x;\n      sprite.y = y;\n\n      //Add getters and setters to the sprite\n      var self = this;\n      Object.defineProperties(sprite, {\n        \"fillStyle\": {\n          get: function get() {\n            return o._fillStyle;\n          },\n          set: function set(value) {\n            o._fillStyle = self.color(value);\n\n            //Draw the new rectangle\n            draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"strokeStyle\": {\n          get: function get() {\n            return o._strokeStyle;\n          },\n          set: function set(value) {\n            o._strokeStyle = self.color(value);\n\n            //Draw the new rectangle\n            draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"lineWidth\": {\n          get: function get() {\n            return o._lineWidth;\n          },\n          set: function set(value) {\n            o._lineWidth = value;\n\n            //Draw the new rectangle\n            draw(o._width, o._height, o._fillStyle, o._strokeStyle, o._lineWidth, o._x, o._y);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        }\n      });\n\n      //Get a local reference to the sprite so that we can\n      //change the rectangle properties later using the getters/setters\n      o._sprite = sprite;\n\n      //Return the sprite\n      return sprite;\n    }\n\n    //Circle\n\n  }, {\n    key: \"circle\",\n    value: function circle() {\n      var diameter = arguments.length <= 0 || arguments[0] === undefined ? 32 : arguments[0];\n      var fillStyle = arguments.length <= 1 || arguments[1] === undefined ? 0xFF3300 : arguments[1];\n      var strokeStyle = arguments.length <= 2 || arguments[2] === undefined ? 0x0033CC : arguments[2];\n      var lineWidth = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n      var x = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];\n      var y = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n\n      var o = new this.Graphics();\n      o._diameter = diameter;\n      o._fillStyle = this.color(fillStyle);\n      o._strokeStyle = this.color(strokeStyle);\n      o._lineWidth = lineWidth;\n\n      //Draw the circle\n      var draw = function draw(diameter, fillStyle, strokeStyle, lineWidth) {\n        o.clear();\n        o.beginFill(fillStyle);\n        if (lineWidth > 0) {\n          o.lineStyle(lineWidth, strokeStyle, 1);\n        }\n        o.drawCircle(0, 0, diameter / 2);\n        o.endFill();\n      };\n\n      //Draw the cirlce\n      draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n      //Generate a texture from the rectangle\n      var texture = o.generateTexture();\n\n      //Use the texture to create a sprite\n      var sprite = new this.Sprite(texture);\n\n      //Position the sprite\n      sprite.x = x;\n      sprite.y = y;\n\n      //Add getters and setters to the sprite\n      var self = this;\n      Object.defineProperties(sprite, {\n        \"fillStyle\": {\n          get: function get() {\n            return o._fillStyle;\n          },\n          set: function set(value) {\n            o._fillStyle = self.color(value);\n\n            //Draw the cirlce\n            draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"strokeStyle\": {\n          get: function get() {\n            return o._strokeStyle;\n          },\n          set: function set(value) {\n            o._strokeStyle = self.color(value);\n\n            //Draw the cirlce\n            draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"diameter\": {\n          get: function get() {\n            return o._diameter;\n          },\n          set: function set(value) {\n            o._lineWidth = 10;\n\n            //Draw the cirlce\n            draw(o._diameter, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"radius\": {\n          get: function get() {\n            return o._diameter / 2;\n          },\n          set: function set(value) {\n\n            //Draw the cirlce\n            draw(value * 2, o._fillStyle, o._strokeStyle, o._lineWidth);\n\n            //Generate a new texture and set it as the sprite's texture\n            var texture = o.generateTexture();\n            o._sprite.texture = texture;\n          },\n\n          enumerable: true, configurable: true\n        }\n      });\n      //Get a local reference to the sprite so that we can\n      //change the circle properties later using the getters/setters\n      o._sprite = sprite;\n\n      //Return the sprite\n      return sprite;\n    }\n\n    //Line\n\n  }, {\n    key: \"line\",\n    value: function line() {\n      var strokeStyle = arguments.length <= 0 || arguments[0] === undefined ? 0x000000 : arguments[0];\n      var lineWidth = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n      var ax = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n      var ay = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n      var bx = arguments.length <= 4 || arguments[4] === undefined ? 32 : arguments[4];\n      var by = arguments.length <= 5 || arguments[5] === undefined ? 32 : arguments[5];\n\n      //Create the line object\n      var o = new this.Graphics();\n\n      //Private properties\n      o._strokeStyle = this.color(strokeStyle);\n      o._width = lineWidth;\n      o._ax = ax;\n      o._ay = ay;\n      o._bx = bx;\n      o._by = by;\n\n      //A helper function that draws the line\n      var draw = function draw(strokeStyle, lineWidth, ax, ay, bx, by) {\n        o.clear();\n        o.lineStyle(lineWidth, strokeStyle, 1);\n        o.moveTo(ax, ay);\n        o.lineTo(bx, by);\n      };\n\n      //Draw the line\n      draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n\n      //Define getters and setters that redefine the line's start and\n      //end points and re-draws it if they change\n      var self = this;\n      Object.defineProperties(o, {\n        \"ax\": {\n          get: function get() {\n            return o._ax;\n          },\n          set: function set(value) {\n            o._ax = value;\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"ay\": {\n          get: function get() {\n            return o._ay;\n          },\n          set: function set(value) {\n            o._ay = value;\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"bx\": {\n          get: function get() {\n            return o._bx;\n          },\n          set: function set(value) {\n            o._bx = value;\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"by\": {\n          get: function get() {\n            return o._by;\n          },\n          set: function set(value) {\n            o._by = value;\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"strokeStyle\": {\n          get: function get() {\n            return o._strokeStyle;\n          },\n          set: function set(value) {\n            o._strokeStyle = self.color(value);\n\n            //Draw the line\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        },\n        \"width\": {\n          get: function get() {\n            return o._width;\n          },\n          set: function set(value) {\n            o._width = value;\n\n            //Draw the line\n            draw(o._strokeStyle, o._width, o._ax, o._ay, o._bx, o._by);\n          },\n\n          enumerable: true, configurable: true\n        }\n      });\n\n      //Return the line\n      return o;\n    }\n\n    /* Compound sprites */\n\n    //Use `grid` to create a grid of sprites\n\n  }, {\n    key: \"grid\",\n    value: function grid() {\n      var columns = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var rows = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var cellWidth = arguments.length <= 2 || arguments[2] === undefined ? 32 : arguments[2];\n      var cellHeight = arguments.length <= 3 || arguments[3] === undefined ? 32 : arguments[3];\n      var centerCell = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n      var xOffset = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n      var yOffset = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n      var makeSprite = arguments.length <= 7 || arguments[7] === undefined ? undefined : arguments[7];\n      var extra = arguments.length <= 8 || arguments[8] === undefined ? undefined : arguments[8];\n\n      //Create an empty group called `container`. This `container`\n      //group is what the function returns back to the main program.\n      //All the sprites in the grid cells will be added\n      //as children to this container\n      var container = new this.Container();\n\n      //The `create` method plots the grid\n\n      var createGrid = function createGrid() {\n\n        //Figure out the number of cells in the grid\n        var length = columns * rows;\n\n        //Create a sprite for each cell\n        for (var i = 0; i < length; i++) {\n\n          //Figure out the sprite's x/y placement in the grid\n          var x = i % columns * cellWidth,\n              y = Math.floor(i / columns) * cellHeight;\n\n          //Use the `makeSprite` function supplied in the constructor\n          //to make a sprite for the grid cell\n          var sprite = makeSprite();\n\n          //Add the sprite to the `container`\n          container.addChild(sprite);\n\n          //Should the sprite be centered in the cell?\n\n          //No, it shouldn't be centered\n          if (!centerCell) {\n            sprite.x = x + xOffset;\n            sprite.y = y + yOffset;\n          }\n\n          //Yes, it should be centered\n          else {\n              sprite.x = x + cellWidth / 2 - sprite.width / 2 + xOffset;\n              sprite.y = y + cellHeight / 2 - sprite.width / 2 + yOffset;\n            }\n\n          //Run any optional extra code. This calls the\n          //`extra` function supplied by the constructor\n          if (extra) extra(sprite);\n        }\n      };\n\n      //Run the `createGrid` method\n      createGrid();\n\n      //Return the `container` group back to the main program\n      return container;\n    }\n\n    //Use `shoot` to create bullet sprites\n\n  }, {\n    key: \"shoot\",\n    value: function shoot(shooter, angle, x, y, container, bulletSpeed, bulletArray, bulletSprite) {\n\n      //Make a new sprite using the user-supplied `bulletSprite` function\n      var bullet = bulletSprite();\n\n      //Set the bullet's anchor point to its center\n      bullet.anchor.set(0.5, 0.5);\n\n      //Temporarily add the bullet to the shooter\n      //so that we can position it relative to the\n      //shooter's position\n      shooter.addChild(bullet);\n      bullet.x = x;\n      bullet.y = y;\n\n      //Find the bullet's global coordinates so that we can use\n      //them to position the bullet on the new parent container\n      var tempGx = bullet.getGlobalPosition().x,\n          tempGy = bullet.getGlobalPosition().y;\n\n      //Add the bullet to the new parent container using\n      //the new global coordinates\n      container.addChild(bullet);\n      bullet.x = tempGx;\n      bullet.y = tempGy;\n\n      //Set the bullet's velocity\n      bullet.vx = Math.cos(angle) * bulletSpeed;\n      bullet.vy = Math.sin(angle) * bulletSpeed;\n\n      //Push the bullet into the `bulletArray`\n      bulletArray.push(bullet);\n    }\n\n    /*\n    grid\n    ----\n     Helps you to automatically create a grid of sprites. `grid` returns a\n    `group` sprite object that contains a sprite for every cell in the\n    grid. You can define the rows and columns in the grid, whether or\n    not the sprites should be centered inside each cell, or what their offset from the\n    top left corner of each cell should be. Supply a function that\n    returns the sprite that you want to make for each cell. You can\n    supply an optional final function that runs any extra code after\n    each sprite has been created. Here's the format for creating a grid:\n         gridGroup = grid(\n           //Set the grid's properties\n          columns, rows, cellWidth, cellHeight,\n          areSpirtesCentered?, xOffset, yOffset,\n           //A function that returns a sprite\n          () => g.circle(16, \"blue\"),\n           //An optional final function that runs some extra code\n          () => console.log(\"extra!\")\n        );\n    */\n\n  }, {\n    key: \"grid\",\n    value: function grid() {\n      var columns = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n      var rows = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var cellWidth = arguments.length <= 2 || arguments[2] === undefined ? 32 : arguments[2];\n      var cellHeight = arguments.length <= 3 || arguments[3] === undefined ? 32 : arguments[3];\n      var centerCell = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];\n      var xOffset = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];\n      var yOffset = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];\n      var makeSprite = arguments.length <= 7 || arguments[7] === undefined ? undefined : arguments[7];\n      var extra = arguments.length <= 8 || arguments[8] === undefined ? undefined : arguments[8];\n\n      //Create an empty group called `container`. This `container`\n      //group is what the function returns back to the main program.\n      //All the sprites in the grid cells will be added\n      //as children to this container\n      var container = this.group();\n\n      //The `create` method plots the grid\n      var createGrid = function createGrid() {\n\n        //Figure out the number of cells in the grid\n        var length = columns * rows;\n\n        //Create a sprite for each cell\n        for (var i = 0; i < length; i++) {\n\n          //Figure out the sprite's x/y placement in the grid\n          var x = i % columns * cellWidth,\n              y = Math.floor(i / columns) * cellHeight;\n\n          //Use the `makeSprite` function supplied in the constructor\n          //to make a sprite for the grid cell\n          var sprite = makeSprite();\n\n          //Add the sprite to the `container`\n          container.addChild(sprite);\n\n          //Should the sprite be centered in the cell?\n\n          //No, it shouldn't be centered\n          if (!centerCell) {\n            sprite.x = x + xOffset;\n            sprite.y = y + yOffset;\n          }\n\n          //Yes, it should be centered\n          else {\n              sprite.x = x + cellWidth / 2 - sprite.halfWidth + xOffset;\n              sprite.y = y + cellHeight / 2 - sprite.halfHeight + yOffset;\n            }\n\n          //Run any optional extra code. This calls the\n          //`extra` function supplied by the constructor\n          if (extra) extra(sprite);\n        }\n      };\n\n      //Run the `createGrid` method\n      createGrid();\n\n      //Return the `container` group back to the main program\n      return container;\n    }\n\n    /*\n    shake\n    -----\n     Used to create a shaking effect, like a screen shake\n    */\n\n  }, {\n    key: \"shake\",\n    value: function shake(sprite) {\n      var magnitude = arguments.length <= 1 || arguments[1] === undefined ? 16 : arguments[1];\n      var angular = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      //Get a reference to this current object so that\n      //it's easy to maintain scope in the nested sub-functions\n      var self = this;\n\n      //A counter to count the number of shakes\n      var counter = 1;\n\n      //The total number of shakes (there will be 1 shake per frame)\n      var numberOfShakes = 10;\n\n      //Capture the sprite's position and angle so you can\n      //restore them after the shaking has finished\n      var startX = sprite.x,\n          startY = sprite.y,\n          startAngle = sprite.rotation;\n\n      //Divide the magnitude into 10 units so that you can\n      //reduce the amount of shake by 10 percent each frame\n      var magnitudeUnit = magnitude / numberOfShakes;\n\n      //The `randomInt` helper function\n      var randomInt = function randomInt(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n      };\n\n      //Add the sprite to the `shakingSprites` array if it\n      //isn't already there\n      if (self.shakingSprites.indexOf(sprite) === -1) {\n\n        self.shakingSprites.push(sprite);\n\n        //Add an `updateShake` method to the sprite.\n        //The `updateShake` method will be called each frame\n        //in the game loop. The shake effect type can be either\n        //up and down (x/y shaking) or angular (rotational shaking).\n        sprite.updateShake = function () {\n          if (angular) {\n            angularShake();\n          } else {\n            upAndDownShake();\n          }\n        };\n      }\n\n      //The `upAndDownShake` function\n      function upAndDownShake() {\n\n        //Shake the sprite while the `counter` is less than\n        //the `numberOfShakes`\n        if (counter < numberOfShakes) {\n\n          //Reset the sprite's position at the start of each shake\n          sprite.x = startX;\n          sprite.y = startY;\n\n          //Reduce the magnitude\n          magnitude -= magnitudeUnit;\n\n          //Randomly change the sprite's position\n          sprite.x += randomInt(-magnitude, magnitude);\n          sprite.y += randomInt(-magnitude, magnitude);\n\n          //Add 1 to the counter\n          counter += 1;\n        }\n\n        //When the shaking is finished, restore the sprite to its original\n        //position and remove it from the `shakingSprites` array\n        if (counter >= numberOfShakes) {\n          sprite.x = startX;\n          sprite.y = startY;\n          self.shakingSprites.splice(self.shakingSprites.indexOf(sprite), 1);\n        }\n      }\n\n      //The `angularShake` function\n      //First set the initial tilt angle to the right (+1)\n      var tiltAngle = 1;\n\n      function angularShake() {\n        if (counter < numberOfShakes) {\n\n          //Reset the sprite's rotation\n          sprite.rotation = startAngle;\n\n          //Reduce the magnitude\n          magnitude -= magnitudeUnit;\n\n          //Rotate the sprite left or right, depending on the direction,\n          //by an amount in radians that matches the magnitude\n          sprite.rotation = magnitude * tiltAngle;\n          counter += 1;\n\n          //Reverse the tilt angle so that the sprite is tilted\n          //in the opposite direction for the next shake\n          tiltAngle *= -1;\n        }\n\n        //When the shaking is finished, reset the sprite's angle and\n        //remove it from the `shakingSprites` array\n        if (counter >= numberOfShakes) {\n          sprite.rotation = startAngle;\n          self.shakingSprites.splice(self.shakingSprites.indexOf(sprite), 1);\n        }\n      }\n    }\n\n    /*\n    _getCenter\n    ----------\n     A utility that finds the center point of the sprite. If it's anchor point is the\n    sprite's top left corner, then the center is calculated from that point.\n    If the anchor point has been shifted, then the anchor x/y point is used as the sprite's center\n    */\n\n  }, {\n    key: \"_getCenter\",\n    value: function _getCenter(o, dimension, axis) {\n      if (o.anchor !== undefined) {\n        if (o.anchor[axis] !== 0) {\n          return 0;\n        } else {\n          return dimension / 2;\n        }\n      } else {\n        return dimension;\n      }\n    }\n\n    /* Groups */\n\n    //Group sprites into a container\n\n  }, {\n    key: \"group\",\n    value: function group() {\n      var container = new this.Container();\n\n      for (var _len = arguments.length, sprites = Array(_len), _key = 0; _key < _len; _key++) {\n        sprites[_key] = arguments[_key];\n      }\n\n      sprites.forEach(function (sprite) {\n        container.addChild(sprite);\n      });\n      return container;\n    }\n\n    //Use the `batch` method to create a ParticleContainer\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var size = arguments.length <= 0 || arguments[0] === undefined ? 15000 : arguments[0];\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { rotation: true, alpha: true, scale: true, uvs: true } : arguments[1];\n\n      var o = new this.ParticleContainer(size, options);\n      return o;\n    }\n\n    //`remove` is a global convenience method that will\n    //remove any sprite, or an argument list of sprites, from its parent.\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      for (var _len2 = arguments.length, sprites = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        sprites[_key2] = arguments[_key2];\n      }\n\n      //Remove sprites that's aren't in an array\n      if (!(sprites[0] instanceof Array)) {\n        if (sprites.length > 1) {\n          sprites.forEach(function (sprite) {\n            sprite.parent.removeChild(sprite);\n          });\n        } else {\n          sprites[0].parent.removeChild(sprites[0]);\n        }\n      }\n\n      //Remove sprites in an array of sprites\n      else {\n          var spritesArray = sprites[0];\n          if (spritesArray.length > 0) {\n            for (var i = spritesArray.length - 1; i >= 0; i--) {\n              var sprite = spritesArray[i];\n              sprite.parent.removeChild(sprite);\n              spritesArray.splice(spritesArray.indexOf(sprite), 1);\n            }\n          }\n        }\n    }\n\n    /* Color conversion */\n    //From: http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes\n    //Utilities to convert HTML color string names to hexadecimal codes\n\n  }, {\n    key: \"colorToRGBA\",\n    value: function colorToRGBA(color) {\n      // Returns the color as an array of [r, g, b, a] -- all range from 0 - 255\n      // color must be a valid canvas fillStyle. This will cover most anything\n      // you'd want to use.\n      // Examples:\n      // colorToRGBA('red')  # [255, 0, 0, 255]\n      // colorToRGBA('#f00') # [255, 0, 0, 255]\n      var cvs, ctx;\n      cvs = document.createElement('canvas');\n      cvs.height = 1;\n      cvs.width = 1;\n      ctx = cvs.getContext('2d');\n      ctx.fillStyle = color;\n      ctx.fillRect(0, 0, 1, 1);\n      var data = ctx.getImageData(0, 0, 1, 1).data;\n      return data;\n    }\n  }, {\n    key: \"byteToHex\",\n    value: function byteToHex(num) {\n      // Turns a number (0-255) into a 2-character hex number (00-ff)\n      return ('0' + num.toString(16)).slice(-2);\n    }\n  }, {\n    key: \"colorToHex\",\n    value: function colorToHex(color) {\n      var _this2 = this;\n\n      // Convert any CSS color to a hex representation\n      // Examples:\n      // colorToHex('red')            # '#ff0000'\n      // colorToHex('rgb(255, 0, 0)') # '#ff0000'\n      var rgba, hex;\n      rgba = this.colorToRGBA(color);\n      hex = [0, 1, 2].map(function (idx) {\n        return _this2.byteToHex(rgba[idx]);\n      }).join('');\n      return \"0x\" + hex;\n    }\n\n    //A function to find out if the user entered a number (a hex color\n    //code) or a string (an HTML color string)\n\n  }, {\n    key: \"color\",\n    value: function color(value) {\n\n      //Check if it's a number\n      if (!isNaN(value)) {\n\n        //Yes, it is a number, so just return it\n        return value;\n      }\n\n      //No it's not a number, so it must be a string   \n      else {\n\n          return this.colorToHex(value);\n          /*\n           //Find out what kind of color string it is.\n          //Let's first grab the first character of the string\n          let firstCharacter = value.charAt(0);\n           //If the first character is a \"#\" or a number, then\n          //we know it must be a RGBA color\n          if (firstCharacter === \"#\") {\n            console.log(\"first character: \" + value.charAt(0))\n          }\n          */\n        }\n\n      /*\n      //Find out if the first character in the string is a number\n      if (!isNaN(parseInt(string.charAt(0)))) {\n        \n        //It's not, so convert it to a hex code\n        return colorToHex(string);\n        \n      //The use input a number, so it must be a hex code. Just return it\n      } else {\n      \n        return string;\n      }\n      \n      */\n    }\n  }]);\n\n  return SpriteUtilities;\n})();\n//# sourceMappingURL=spriteUtilities.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar GameUtilities = (function () {\n  function GameUtilities() {\n    _classCallCheck(this, GameUtilities);\n  }\n\n  /*\n  distance\n  ----------------\n   Find the distance in pixels between two sprites.\n  Parameters: \n  a. A sprite object. \n  b. A sprite object. \n  The function returns the number of pixels distance between the sprites.\n      let distanceBetweenSprites = gu.distance(spriteA, spriteB);\n   */\n\n  _createClass(GameUtilities, [{\n    key: \"distance\",\n    value: function distance(s1, s2) {\n      var vx = s2.x + this._getCenter(s2, s2.width, \"x\") - (s1.x + this._getCenter(s1, s1.width, \"x\")),\n          vy = s2.y + this._getCenter(s2, s2.height, \"y\") - (s1.y + this._getCenter(s1, s1.height, \"y\"));\n      return Math.sqrt(vx * vx + vy * vy);\n    }\n\n    /*\n    followEase\n    ----------------\n     Make a sprite ease to the position of another sprite.\n    Parameters: \n    a. A sprite object. This is the `follower` sprite.\n    b. A sprite object. This is the `leader` sprite that the follower will chase.\n    c. The easing value, such as 0.3. A higher number makes the follower move faster.\n        gu.followEase(follower, leader, speed);\n     Use it inside a game loop.\n    */\n\n  }, {\n    key: \"followEase\",\n    value: function followEase(follower, leader, speed) {\n\n      //Figure out the distance between the sprites\n      /*\n      let vx = (leader.x + leader.width / 2) - (follower.x + follower.width / 2),\n          vy = (leader.y + leader.height / 2) - (follower.y + follower.height / 2),\n          distance = Math.sqrt(vx * vx + vy * vy);\n      */\n\n      var vx = leader.x + this._getCenter(leader, leader.width, \"x\") - (follower.x + this._getCenter(follower, follower.width, \"x\")),\n          vy = leader.y + this._getCenter(leader, leader.height, \"y\") - (follower.y + this._getCenter(follower, follower.height, \"y\")),\n          distance = Math.sqrt(vx * vx + vy * vy);\n\n      //Move the follower if it's more than 1 pixel\n      //away from the leader\n      if (distance >= 1) {\n        follower.x += vx * speed;\n        follower.y += vy * speed;\n      }\n    }\n\n    /*\n    followConstant\n    ----------------\n     Make a sprite move towards another sprite at a constant speed.\n    Parameters: \n    a. A sprite object. This is the `follower` sprite.\n    b. A sprite object. This is the `leader` sprite that the follower will chase.\n    c. The speed value, such as 3. The is the pixels per frame that the sprite will move. A higher number makes the follower move faster.\n        gu.followConstant(follower, leader, speed);\n     */\n\n  }, {\n    key: \"followConstant\",\n    value: function followConstant(follower, leader, speed) {\n\n      //Figure out the distance between the sprites\n      var vx = leader.x + this._getCenter(leader, leader.width, \"x\") - (follower.x + this._getCenter(follower, follower.width, \"x\")),\n          vy = leader.y + this._getCenter(leader, leader.height, \"y\") - (follower.y + this._getCenter(follower, follower.height, \"y\")),\n          distance = Math.sqrt(vx * vx + vy * vy);\n\n      //Move the follower if it's more than 1 move\n      //away from the leader\n      if (distance >= speed) {\n        follower.x += vx / distance * speed;\n        follower.y += vy / distance * speed;\n      }\n    }\n\n    /*\n    angle\n    -----\n     Return the angle in Radians between two sprites.\n    Parameters: \n    a. A sprite object.\n    b. A sprite object.\n    You can use it to make a sprite rotate towards another sprite like this:\n         box.rotation = angle(box, pointer);\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle(s1, s2) {\n      return Math.atan2(\n      //This is the code you need if you don't want to compensate\n      //for a possible shift in the sprites' x/y anchor points\n      /*\n      (s2.y + s2.height / 2) - (s1.y + s1.height / 2),\n      (s2.x + s2.width / 2) - (s1.x + s1.width / 2)\n      */\n      //This code adapts to a shifted anchor point\n      s2.y + this._getCenter(s2, s2.height, \"y\") - (s1.y + this._getCenter(s1, s1.height, \"y\")), s2.x + this._getCenter(s2, s2.width, \"x\") - (s1.x + this._getCenter(s1, s1.width, \"x\")));\n    }\n\n    /*\n    _getCenter\n    ----------\n     A utility that finds the center point of the sprite. If it's anchor point is the\n    sprite's top left corner, then the center is calculated from that point.\n    If the anchor point has been shifted, then the anchor x/y point is used as the sprite's center\n    */\n\n  }, {\n    key: \"_getCenter\",\n    value: function _getCenter(o, dimension, axis) {\n      if (o.anchor !== undefined) {\n        if (o.anchor[axis] !== 0) {\n          return 0;\n        } else {\n          //console.log(o.anchor[axis])\n          return dimension / 2;\n        }\n      } else {\n        return dimension;\n      }\n    }\n\n    /*\n    rotateAroundSprite\n    ------------\n    Make a sprite rotate around another sprite.\n    Parameters:\n    a. The sprite you want to rotate.\n    b. The sprite around which you want to rotate the first sprite.\n    c. The distance, in pixels, that the roating sprite should be offset from the center.\n    d. The angle of rotations, in radians.\n        gu.rotateAroundSprite(orbitingSprite, centerSprite, 50, angleInRadians);\n     Use it inside a game loop, and make sure you update the angle value (the 4th argument) each frame.\n    */\n\n  }, {\n    key: \"rotateAroundSprite\",\n    value: function rotateAroundSprite(rotatingSprite, centerSprite, distance, angle) {\n      rotatingSprite.x = centerSprite.x + this._getCenter(centerSprite, centerSprite.width, \"x\") - rotatingSprite.parent.x + distance * Math.cos(angle) - this._getCenter(rotatingSprite, rotatingSprite.width, \"x\");\n\n      rotatingSprite.y = centerSprite.y + this._getCenter(centerSprite, centerSprite.height, \"y\") - rotatingSprite.parent.y + distance * Math.sin(angle) - this._getCenter(rotatingSprite, rotatingSprite.height, \"y\");\n    }\n\n    /*\n    rotateAroundPoint\n    -----------------\n    Make a point rotate around another point.\n    Parameters:\n    a. The point you want to rotate.\n    b. The point around which you want to rotate the first point.\n    c. The distance, in pixels, that the roating sprite should be offset from the center.\n    d. The angle of rotations, in radians.\n        gu.rotateAroundPoint(orbitingPoint, centerPoint, 50, angleInRadians);\n     Use it inside a game loop, and make sure you update the angle value (the 4th argument) each frame.\n     */\n\n  }, {\n    key: \"rotateAroundPoint\",\n    value: function rotateAroundPoint(pointX, pointY, distanceX, distanceY, angle) {\n      var point = {};\n      point.x = pointX + Math.cos(angle) * distanceX;\n      point.y = pointY + Math.sin(angle) * distanceY;\n      return point;\n    }\n\n    /*\n    randomInt\n    ---------\n     Return a random integer between a minimum and maximum value\n    Parameters: \n    a. An integer.\n    b. An integer.\n    Here's how you can use it to get a random number between, 1 and 10:\n        let number = gu.randomInt(1, 10);\n     */\n\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    /*\n    randomFloat\n    -----------\n     Return a random floating point number between a minimum and maximum value\n    Parameters: \n    a. Any number.\n    b. Any number.\n    Here's how you can use it to get a random floating point number between, 1 and 10:\n         let number = gu.randomFloat(1, 10);\n     */\n\n  }, {\n    key: \"randomFloat\",\n    value: function randomFloat(min, max) {\n      return min + Math.random() * (max - min);\n    }\n\n    /*\n    Wait\n    ----\n     Lets you wait for a specific number of milliseconds before running the\n    next function. \n     \n      wait(1000, runThisFunctionNext());\n    \n    */\n\n  }, {\n    key: \"wait\",\n    value: function wait(duration, callBack) {\n      setTimeout(callBack, duration);\n    }\n\n    /*\n    Move\n    ----\n     Move a sprite by adding it's velocity to it's position. The sprite \n    must have `vx` and `vy` values for this to work. You can supply a\n    single sprite, or a list of sprites, separated by commas.\n         move(sprite);\n    */\n\n  }, {\n    key: \"move\",\n    value: function move() {\n      for (var _len = arguments.length, sprites = Array(_len), _key = 0; _key < _len; _key++) {\n        sprites[_key] = arguments[_key];\n      }\n\n      //Move sprites that's aren't in an array\n      if (!(sprites[0] instanceof Array)) {\n        if (sprites.length > 1) {\n          sprites.forEach(function (sprite) {\n            sprite.x += sprite.vx;\n            sprite.y += sprite.vy;\n          });\n        } else {\n          sprites[0].x += sprites[0].vx;\n          sprites[0].y += sprites[0].vy;\n        }\n      }\n\n      //Move sprites in an array of sprites\n      else {\n          var spritesArray = sprites[0];\n          if (spritesArray.length > 0) {\n            for (var i = spritesArray.length - 1; i >= 0; i--) {\n              var sprite = spritesArray[i];\n              sprite.x += sprite.vx;\n              sprite.y += sprite.vy;\n            }\n          }\n        }\n    }\n\n    /*\n    World camera\n    ------------\n     The `worldCamera` method returns a `camera` object\n    with `x` and `y` properties. It has\n    two useful methods: `centerOver`, to center the camera over\n    a sprite, and `follow` to make it follow a sprite.\n    `worldCamera` arguments: worldObject, theCanvas\n    The worldObject needs to have a `width` and `height` property.\n    */\n\n  }, {\n    key: \"worldCamera\",\n    value: function worldCamera(world, worldWidth, worldHeight, canvas) {\n\n      //Define a `camera` object with helpful properties\n      var camera = {\n        width: canvas.width,\n        height: canvas.height,\n        _x: 0,\n        _y: 0,\n\n        //`x` and `y` getters/setters\n        //When you change the camera's position,\n        //they shift the position of the world in the opposite direction\n        get x() {\n          return this._x;\n        },\n        set x(value) {\n          this._x = value;\n          world.x = -this._x;\n          //world._previousX = world.x;\n        },\n        get y() {\n          return this._y;\n        },\n        set y(value) {\n          this._y = value;\n          world.y = -this._y;\n          //world._previousY = world.y;\n        },\n\n        //The center x and y position of the camera\n        get centerX() {\n          return this.x + this.width / 2;\n        },\n        get centerY() {\n          return this.y + this.height / 2;\n        },\n\n        //Boundary properties that define a rectangular area, half the size\n        //of the game screen. If the sprite that the camera is following\n        //is inide this area, the camera won't scroll. If the sprite\n        //crosses this boundary, the `follow` function ahead will change\n        //the camera's x and y position to scroll the game world\n        get rightInnerBoundary() {\n          return this.x + this.width / 2 + this.width / 4;\n        },\n        get leftInnerBoundary() {\n          return this.x + this.width / 2 - this.width / 4;\n        },\n        get topInnerBoundary() {\n          return this.y + this.height / 2 - this.height / 4;\n        },\n        get bottomInnerBoundary() {\n          return this.y + this.height / 2 + this.height / 4;\n        },\n\n        //The code next defines two camera\n        //methods: `follow` and `centerOver`\n\n        //Use the `follow` method to make the camera follow a sprite\n        follow: function follow(sprite) {\n\n          //Check the sprites position in relation to the inner\n          //boundary. Move the camera to follow the sprite if the sprite\n          //strays outside the boundary\n          if (sprite.x < this.leftInnerBoundary) {\n            this.x = sprite.x - this.width / 4;\n          }\n          if (sprite.y < this.topInnerBoundary) {\n            this.y = sprite.y - this.height / 4;\n          }\n          if (sprite.x + sprite.width > this.rightInnerBoundary) {\n            this.x = sprite.x + sprite.width - this.width / 4 * 3;\n          }\n          if (sprite.y + sprite.height > this.bottomInnerBoundary) {\n            this.y = sprite.y + sprite.height - this.height / 4 * 3;\n          }\n\n          //If the camera reaches the edge of the map, stop it from moving\n          if (this.x < 0) {\n            this.x = 0;\n          }\n          if (this.y < 0) {\n            this.y = 0;\n          }\n          if (this.x + this.width > worldWidth) {\n            this.x = worldWidth - this.width;\n          }\n          if (this.y + this.height > worldHeight) {\n            this.y = worldHeight - this.height;\n          }\n        },\n\n        //Use the `centerOver` method to center the camera over a sprite\n        centerOver: function centerOver(sprite) {\n\n          //Center the camera over a sprite\n          this.x = sprite.x + sprite.halfWidth - this.width / 2;\n          this.y = sprite.y + sprite.halfHeight - this.height / 2;\n        }\n      };\n\n      //Return the `camera` object\n      return camera;\n    }\n  }]);\n\n  return GameUtilities;\n})();\n//# sourceMappingURL=gameUtilities.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Smoothie = (function () {\n  function Smoothie() //Refers to `tileposition` and `tileScale` x and y properties\n  {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {\n      engine: PIXI, //The rendering engine (Pixi)\n      renderer: undefined, //The Pixi renderer you created in your application\n      root: undefined, //The root Pixi display object (usually the `stage`)\n      update: undefined, //A logic function that should be called every frame of the game loop\n      interpolate: true, //A Boolean to turn interpolation on or off\n      fps: 60, //The frame rate at which the application's looping logic function should update\n      renderFps: undefined, //The frame rate at which sprites should be rendered\n      properties: { //Sprite roperties that should be interpolated\n        position: true,\n        rotation: true,\n        size: false,\n        scale: false,\n        alpha: false,\n        tile: false }\n    } : arguments[0];\n\n    _classCallCheck(this, Smoothie);\n\n    if (options.engine === undefined) throw new Error(\"Please assign a rendering engine as Smoothie's engine option\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.engine = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (options.engine.ParticleContainer && options.engine.Sprite) {\n      this.renderingEngine = \"pixi\";\n      this.Container = options.engine.Container;\n      this.Sprite = options.engine.Sprite;\n      this.MovieClip = options.engine.extras.MovieClip;\n    }\n\n    //Check to make sure the user had supplied a renderer. If you're\n    //using Pixi, this should be the instantiated `renderer` object\n    //that you created in your main application\n    if (options.renderer === undefined) {\n      throw new Error(\"Please assign a renderer object as Smoothie's renderer option\");\n    } else {\n      this.renderer = options.renderer;\n    }\n\n    //Check to make sure the user has supplied a root container. This\n    //is the object is at the top of the display list heirarchy. If\n    //you're using Pixi, it would be a `Container` object, often by\n    //convention called the `stage`\n    if (options.root === undefined) {\n      throw new Error(\"Please assign a root container object (the stage) as Smoothie's rootr option\");\n    } else {\n      this.stage = options.root;\n    }\n\n    if (options.update === undefined) {\n      throw new Error(\"Please assign a function that you want to update on each frame as Smoothie's update option\");\n    } else {\n      this.update = options.update;\n    }\n\n    //Define the sprite properties that should be interpolated\n    if (options.properties === undefined) {\n      this.properties = { position: true, rotation: true };\n    } else {\n      this.properties = options.properties;\n    }\n\n    //The upper-limit frames per second that the game' logic update\n    //function should run at.\n    //Smoothie defaults to 60 fps.\n    if (options.fps !== undefined) {\n      this._fps = options.fps;\n    } else {\n      this._fps = undefined;\n    }\n\n    //Optionally Clamp the upper-limit frame rate at which sprites should render\n    if (options.renderFps !== undefined) {\n      this._renderFps = options.renderFps;\n    } else {\n      this._renderFps = undefined;\n    }\n    //Set sprite rendering position interpolation to\n    //`true` by default\n    if (options.interpolate === false) {\n      this.interpolate = false;\n    } else {\n      this.interpolate = true;\n    }\n\n    //A variable that can be used to pause and play Smoothie\n    this.paused = false;\n\n    //Private properties used to set the frame rate and figure out the interpolation values\n    this._startTime = Date.now();\n    this._frameDuration = 1000 / this._fps;\n    this._lag = 0;\n    this._lagOffset = 0;\n\n    this._renderStartTime = 0;\n    if (this._renderFps !== undefined) {\n      this._renderDuration = 1000 / this._renderFps;\n    }\n  }\n\n  //Getters and setters\n\n  //Fps\n\n  _createClass(Smoothie, [{\n    key: \"pause\",\n\n    //Methods to pause and resume Smoothie\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n\n    //The `start` method gets Smoothie's game loop running\n\n  }, {\n    key: \"start\",\n    value: function start() {\n\n      //Start the game loop\n      this.gameLoop();\n    }\n\n    //The core game loop\n\n  }, {\n    key: \"gameLoop\",\n    value: function gameLoop(timestamp) {\n      var _this = this;\n\n      requestAnimationFrame(this.gameLoop.bind(this));\n\n      //Only run if Smoothie isn't paused\n      if (!this.paused) {\n\n        //The `interpolate` function updates the logic function at the\n        //same rate as the user-defined fps, renders the sprites, with\n        //interpolation, at the maximum frame rate the system is capbale\n        //of\n\n        var interpolate = function interpolate() {\n\n          //Calculate the time that has elapsed since the last frame\n          var current = Date.now(),\n              elapsed = current - _this._startTime;\n\n          //Catch any unexpectedly large frame rate spikes\n          if (elapsed > 1000) elapsed = _this._frameDuration;\n\n          //For interpolation:\n          _this._startTime = current;\n\n          //Add the elapsed time to the lag counter\n          _this._lag += elapsed;\n\n          //Update the frame if the lag counter is greater than or\n          //equal to the frame duration\n          while (_this._lag >= _this._frameDuration) {\n\n            //Capture the sprites' previous properties for rendering\n            //interpolation\n            _this.capturePreviousSpriteProperties();\n\n            //Update the logic in the user-defined update function\n            _this.update();\n\n            //Reduce the lag counter by the frame duration\n            _this._lag -= _this._frameDuration;\n          }\n\n          //Calculate the lag offset and use it to render the sprites\n          _this._lagOffset = _this._lag / _this._frameDuration;\n          _this.render(_this._lagOffset);\n        };\n\n        //If the `fps` hasn't been defined, call the user-defined update\n        //function and render the sprites at the maximum rate the\n        //system is capable of\n        if (this._fps === undefined) {\n\n          //Run the user-defined game logic function each frame of the\n          //game at the maxium frame rate your system is capable of\n          this.update();\n          this.render();\n        } else {\n          if (this._renderFps === undefined) {\n            interpolate();\n          } else {\n\n            //Implement optional frame rate rendering clamping\n            if (timestamp >= this._renderStartTime) {\n\n              //Update the current logic frame and render with\n              //interpolation\n              interpolate();\n\n              //Reset the frame render start time\n              this._renderStartTime = timestamp + this._renderDuration;\n            }\n          }\n        }\n      }\n    }\n\n    //`capturePreviousSpritePositions`\n    //This function is run in the game loop just before the logic update\n    //to store all the sprites' previous positions from the last frame.\n    //It allows the render function to interpolate the sprite positions\n    //for ultra-smooth sprite rendering at any frame rate\n\n  }, {\n    key: \"capturePreviousSpriteProperties\",\n    value: function capturePreviousSpriteProperties() {\n      var _this2 = this;\n\n      //A function that capture's the sprites properties\n      var setProperties = function setProperties(sprite) {\n        if (_this2.properties.position) {\n          sprite._previousX = sprite.x;\n          sprite._previousY = sprite.y;\n        }\n        if (_this2.properties.rotation) {\n          sprite._previousRotation = sprite.rotation;\n        }\n        if (_this2.properties.size) {\n          sprite._previousWidth = sprite.width;\n          sprite._previousHeight = sprite.height;\n        }\n        if (_this2.properties.scale) {\n          sprite._previousScaleX = sprite.scale.x;\n          sprite._previousScaleY = sprite.scale.y;\n        }\n        if (_this2.properties.alpha) {\n          sprite._previousAlpha = sprite.alpha;\n        }\n        if (_this2.properties.tile) {\n          if (sprite.tilePosition !== undefined) {\n            sprite._previousTilePositionX = sprite.tilePosition.x;\n            sprite._previousTilePositionY = sprite.tilePosition.y;\n          }\n          if (sprite.tileScale !== undefined) {\n            sprite._previousTileScaleX = sprite.tileScale.x;\n            sprite._previousTileScaleY = sprite.tileScale.y;\n          }\n        }\n\n        if (sprite.children && sprite.children.length > 0) {\n          for (var i = 0; i < sprite.children.length; i++) {\n            var child = sprite.children[i];\n            setProperties(child);\n          }\n        }\n      };\n\n      //loop through the all the sprites and capture their properties\n      for (var i = 0; i < this.stage.children.length; i++) {\n        var sprite = this.stage.children[i];\n        setProperties(sprite);\n      }\n    }\n\n    //Smoothie's `render` method will interpolate the sprite positions and\n    //rotation for\n    //ultra-smooth animation, if Hexi's `interpolate` property is `true`\n    //(it is by default)\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var lagOffset = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      //Calculate the sprites' interpolated render positions if\n      //`this.interpolate` is `true` (It is true by default)\n\n      if (this.interpolate) {\n        (function () {\n\n          //A recursive function that does the work of figuring out the\n          //interpolated positions\n          var interpolateSprite = function interpolateSprite(sprite) {\n\n            //Position (`x` and `y` properties)\n            if (_this3.properties.position) {\n\n              //Capture the sprite's current x and y positions\n              sprite._currentX = sprite.x;\n              sprite._currentY = sprite.y;\n\n              //Figure out its interpolated positions\n              if (sprite._previousX !== undefined) {\n                sprite.x = (sprite.x - sprite._previousX) * lagOffset + sprite._previousX;\n              }\n              if (sprite._previousY !== undefined) {\n                sprite.y = (sprite.y - sprite._previousY) * lagOffset + sprite._previousY;\n              }\n            }\n\n            //Rotation (`rotation` property)\n            if (_this3.properties.rotation) {\n\n              //Capture the sprite's current rotation\n              sprite._currentRotation = sprite.rotation;\n\n              //Figure out its interpolated rotation\n              if (sprite._previousRotation !== undefined) {\n                sprite.rotation = (sprite.rotation - sprite._previousRotation) * lagOffset + sprite._previousRotation;\n              }\n            }\n\n            //Size (`width` and `height` properties)\n            if (_this3.properties.size) {\n\n              //Only allow this for Sprites or MovieClips. Because\n              //Containers vary in size when the sprites they contain\n              //move, the interpolation will cause them to scale erraticly\n              if (sprite instanceof _this3.Sprite || sprite instanceof _this3.MovieClip) {\n\n                //Capture the sprite's current size\n                sprite._currentWidth = sprite.width;\n                sprite._currentHeight = sprite.height;\n\n                //Figure out the sprite's interpolated size\n                if (sprite._previousWidth !== undefined) {\n                  sprite.width = (sprite.width - sprite._previousWidth) * lagOffset + sprite._previousWidth;\n                }\n                if (sprite._previousHeight !== undefined) {\n                  sprite.height = (sprite.height - sprite._previousHeight) * lagOffset + sprite._previousHeight;\n                }\n              }\n            }\n\n            //Scale (`scale.x` and `scale.y` properties)\n            if (_this3.properties.scale) {\n\n              //Capture the sprite's current scale\n              sprite._currentScaleX = sprite.scale.x;\n              sprite._currentScaleY = sprite.scale.y;\n\n              //Figure out the sprite's interpolated scale\n              if (sprite._previousScaleX !== undefined) {\n                sprite.scale.x = (sprite.scale.x - sprite._previousScaleX) * lagOffset + sprite._previousScaleX;\n              }\n              if (sprite._previousScaleY !== undefined) {\n                sprite.scale.y = (sprite.scale.y - sprite._previousScaleY) * lagOffset + sprite._previousScaleY;\n              }\n            }\n\n            //Alpha (`alpha` property)\n            if (_this3.properties.alpha) {\n\n              //Capture the sprite's current alpha\n              sprite._currentAlpha = sprite.alpha;\n\n              //Figure out its interpolated alpha\n              if (sprite._previousAlpha !== undefined) {\n                sprite.alpha = (sprite.alpha - sprite._previousAlpha) * lagOffset + sprite._previousAlpha;\n              }\n            }\n\n            //Tiling sprite properties (`tileposition` and `tileScale` x\n            //and y values)\n            if (_this3.properties.tile) {\n\n              //`tilePosition.x` and `tilePosition.y`\n              if (sprite.tilePosition !== undefined) {\n\n                //Capture the sprite's current tile x and y positions\n                sprite._currentTilePositionX = sprite.tilePosition.x;\n                sprite._currentTilePositionY = sprite.tilePosition.y;\n\n                //Figure out its interpolated positions\n                if (sprite._previousTilePositionX !== undefined) {\n                  sprite.tilePosition.x = (sprite.tilePosition.x - sprite._previousTilePositionX) * lagOffset + sprite._previousTilePositionX;\n                }\n                if (sprite._previousTilePositionY !== undefined) {\n                  sprite.tilePosition.y = (sprite.tilePosition.y - sprite._previousTilePositionY) * lagOffset + sprite._previousTilePositionY;\n                }\n              }\n\n              //`tileScale.x` and `tileScale.y`\n              if (sprite.tileScale !== undefined) {\n\n                //Capture the sprite's current tile scale\n                sprite._currentTileScaleX = sprite.tileScale.x;\n                sprite._currentTileScaleY = sprite.tileScale.y;\n\n                //Figure out the sprite's interpolated scale\n                if (sprite._previousTileScaleX !== undefined) {\n                  sprite.tileScale.x = (sprite.tileScale.x - sprite._previousTileScaleX) * lagOffset + sprite._previousTileScaleX;\n                }\n                if (sprite._previousTileScaleY !== undefined) {\n                  sprite.tileScale.y = (sprite.tileScale.y - sprite._previousTileScaleY) * lagOffset + sprite._previousTileScaleY;\n                }\n              }\n            }\n\n            //Interpolate the sprite's children, if it has any\n            if (sprite.children.length !== 0) {\n              for (var j = 0; j < sprite.children.length; j++) {\n\n                //Find the sprite's child\n                var child = sprite.children[j];\n\n                //display the child\n                interpolateSprite(child);\n              }\n            }\n          };\n\n          //loop through the all the sprites and interpolate them\n          for (var i = 0; i < _this3.stage.children.length; i++) {\n            var sprite = _this3.stage.children[i];\n            interpolateSprite(sprite);\n          }\n        })();\n      }\n\n      //Render the stage. If the sprite positions have been\n      //interpolated, those position values will be used to render the\n      //sprite\n      this.renderer.render(this.stage);\n\n      //Restore the sprites' original x and y values if they've been\n      //interpolated for this frame\n      if (this.interpolate) {\n        (function () {\n\n          //A recursive function that restores the sprite's original,\n          //uninterpolated x and y positions\n          var restoreSpriteProperties = function restoreSpriteProperties(sprite) {\n            if (_this3.properties.position) {\n              sprite.x = sprite._currentX;\n              sprite.y = sprite._currentY;\n            }\n            if (_this3.properties.rotation) {\n              sprite.rotation = sprite._currentRotation;\n            }\n            if (_this3.properties.size) {\n\n              //Only allow this for Sprites or Movie clips, to prevent\n              //Container scaling bug\n              if (sprite instanceof _this3.Sprite || sprite instanceof _this3.MovieClip) {\n                sprite.width = sprite._currentWidth;\n                sprite.height = sprite._currentHeight;\n              }\n            }\n            if (_this3.properties.scale) {\n              sprite.scale.x = sprite._currentScaleX;\n              sprite.scale.y = sprite._currentScaleY;\n            }\n            if (_this3.properties.alpha) {\n              sprite.alpha = sprite._currentAlpha;\n            }\n            if (_this3.properties.tile) {\n              if (sprite.tilePosition !== undefined) {\n                sprite.tilePosition.x = sprite._currentTilePositionX;\n                sprite.tilePosition.y = sprite._currentTilePositionY;\n              }\n              if (sprite.tileScale !== undefined) {\n                sprite.tileScale.x = sprite._currentTileScaleX;\n                sprite.tileScale.y = sprite._currentTileScaleY;\n              }\n            }\n\n            //Restore the sprite's children, if it has any\n            if (sprite.children.length !== 0) {\n              for (var i = 0; i < sprite.children.length; i++) {\n\n                //Find the sprite's child\n                var child = sprite.children[i];\n\n                //Restore the child sprite properties\n                restoreSpriteProperties(child);\n              }\n            }\n          };\n          for (var i = 0; i < _this3.stage.children.length; i++) {\n            var sprite = _this3.stage.children[i];\n            restoreSpriteProperties(sprite);\n          }\n        })();\n      }\n    }\n  }, {\n    key: \"fps\",\n    get: function get() {\n      return this._fps;\n    },\n    set: function set(value) {\n      this._fps = value;\n      this._frameDuration = 1000 / this._fps;\n    }\n\n    //renderFps\n\n  }, {\n    key: \"renderFps\",\n    get: function get() {\n      return this._renderFps;\n    },\n    set: function set(value) {\n      this._renderFps = value;\n      this._renderDuration = 1000 / this._renderFps;\n    }\n\n    //`dt` (Delta time, the `this._lagOffset` value in Smoothie's code)\n\n  }, {\n    key: \"dt\",\n    get: function get() {\n      return this._lagOffset;\n    }\n  }]);\n\n  return Smoothie;\n})();\n//# sourceMappingURL=smoothie.js.map","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TileUtilities = (function () {\n  function TileUtilities() {\n    var renderingEngine = arguments.length <= 0 || arguments[0] === undefined ? PIXI : arguments[0];\n\n    _classCallCheck(this, TileUtilities);\n\n    if (renderingEngine === undefined) throw new Error(\"Please assign a rendering engine in the constructor before using bump.js\");\n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderingEngine = renderingEngine;\n      this.renderer = \"pixi\";\n      this.Container = this.renderingEngine.Container;\n      this.TextureCache = this.renderingEngine.utils.TextureCache;\n      this.Texture = this.renderingEngine.Texture;\n      this.Sprite = this.renderingEngine.Sprite;\n      this.Rectangle = this.renderingEngine.Rectangle;\n      this.Graphics = this.renderingEngine.Graphics;\n      this.loader = this.renderingEngine.loader;\n      this.resources = this.renderingEngine.loader.resources;\n    }\n  }\n\n  //Make a texture from a frame in another texture or image\n\n  _createClass(TileUtilities, [{\n    key: \"frame\",\n    value: function frame(source, x, y, width, height) {\n\n      var texture = undefined,\n          imageFrame = undefined;\n\n      //If the source is a string, it's either a texture in the\n      //cache or an image file\n      if (typeof source === \"string\") {\n        if (this.TextureCache[source]) {\n          texture = new this.Texture(this.TextureCache[source]);\n        }\n      }\n\n      //If the `source` is a texture,  use it\n      else if (source instanceof this.Texture) {\n          texture = new this.Texture(source);\n        }\n      if (!texture) {\n        throw new Error(\"Please load the \" + source + \" texture into the cache.\");\n      } else {\n\n        //Make a rectangle the size of the sub-image\n        imageFrame = new this.Rectangle(x, y, width, height);\n        texture.frame = imageFrame;\n        return texture;\n      }\n    }\n\n    //#### getIndex\n    //The `getIndex` helper method\n    //converts a sprite's x and y position to an array index number.\n    //It returns a single index value that tells you the map array\n    //index number that the sprite is in\n\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(x, y, tilewidth, tileheight, mapWidthInTiles) {\n      var index = {};\n\n      //Convert pixel coordinates to map index coordinates\n      index.x = Math.floor(x / tilewidth);\n      index.y = Math.floor(y / tileheight);\n\n      //Return the index number\n      return index.x + index.y * mapWidthInTiles;\n    }\n\n    /*\n    #### getTile\n    The `getTile` helper method\n    converts a tile's index number into x/y screen\n    coordinates, and capture's the tile's grid index (`gid`) number.\n    It returns an object with `x`, `y`, `centerX`, `centerY`, `width`, `height`, `halfWidth`\n    `halffHeight` and `gid` properties. (The `gid` number is the value that the tile has in the\n    mapArray) This lets you use the returned object\n    with the 2d geometric collision functions like `hitTestRectangle`\n    or `rectangleCollision`\n     The `world` object requires these properties:\n    `x`, `y`, `tilewidth`, `tileheight` and `widthInTiles`\n    */\n\n  }, {\n    key: \"getTile\",\n    value: function getTile(index, mapArray, world) {\n      var tile = {};\n      tile.gid = mapArray[index];\n      tile.width = world.tilewidth;\n      tile.height = world.tileheight;\n      tile.halfWidth = world.tilewidth / 2;\n      tile.halfHeight = world.tileheight / 2;\n      tile.x = index % world.widthInTiles * world.tilewidth + world.x;\n      tile.y = Math.floor(index / world.widthInTiles) * world.tileheight + world.y;\n      tile.gx = tile.x;\n      tile.gy = tile.y;\n      tile.centerX = tile.x + world.tilewidth / 2;\n      tile.centery = tile.y + world.tileheight / 2;\n\n      //Return the tile object\n      return tile;\n    }\n\n    /*\n    #### surroundingCells\n    The `surroundingCells` helper method returns an array containing 9\n    index numbers of map array cells around any given index number.\n    Use it for an efficient broadphase/narrowphase collision test.\n    The 2 arguments are the index number that represents the center cell,\n    and the width of the map array.\n    */\n\n  }, {\n    key: \"surroundingCells\",\n    value: function surroundingCells(index, widthInTiles) {\n      return [index - widthInTiles - 1, index - widthInTiles, index - widthInTiles + 1, index - 1, index, index + 1, index + widthInTiles - 1, index + widthInTiles, index + widthInTiles + 1];\n    }\n\n    //#### getPoints\n    /*\n    The `getPoints` method takes a sprite and returns\n    an object that tells you what all its corner points are. The return\n    object has four properties, each of which is an object with `x` and `y` properties:\n     - `topLeft`: `x` and `y` properties describing the top left corner\n    point.\n    - `topRight`: `x` and `y` properties describing the top right corner\n    point.\n    - `bottomLeft`: `x` and `y` properties describing the bottom left corner\n    point.\n    - `bottomRight`: `x` and `y` properties describing the bottom right corner\n    point.\n     If the sprite has a `collisionArea` property that defines a\n    smaller rectangular area inside the sprite, that collision\n    area can be used instead for collisions instead of the sprite's dimensions. Here's\n    How you could define a `collsionArea` on a sprite called `elf`:\n    ```js\n    elf.collisionArea = {x: 22, y: 44, width: 20, height: 20};\n    ```\n    Here's how you could use the `getPoints` method to find all the collision area's corner points.\n    ```js\n    let cornerPoints = tu.getPoints(elf.collisionArea);\n    ```\n    */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints(s) {\n      var ca = s.collisionArea;\n      if (ca !== undefined) {\n        return {\n          topLeft: {\n            x: s.x + ca.x,\n            y: s.y + ca.y\n          },\n          topRight: {\n            x: s.x + ca.x + ca.width,\n            y: s.y + ca.y\n          },\n          bottomLeft: {\n            x: s.x + ca.x,\n            y: s.y + ca.y + ca.height\n          },\n          bottomRight: {\n            x: s.x + ca.x + ca.width,\n            y: s.y + ca.y + ca.height\n          }\n        };\n      } else {\n        return {\n          topLeft: {\n            x: s.x,\n            y: s.y\n          },\n          topRight: {\n            x: s.x + s.width - 1,\n            y: s.y\n          },\n          bottomLeft: {\n            x: s.x,\n            y: s.y + s.height - 1\n          },\n          bottomRight: {\n            x: s.x + s.width - 1,\n            y: s.y + s.height - 1\n          }\n        };\n      }\n    }\n\n    //### hitTestTile\n    /*\n    `hitTestTile` checks for a\n    collision between a sprite and a tile in any map array that you\n    specify. It returns a `collision` object.\n    `collision.hit` is a Boolean that tells you if a sprite is colliding\n    with the tile that you're checking. `collision.index` tells you the\n    map array's index number of the colliding sprite. You can check for\n    a collision with the tile against \"every\" corner point on the\n    sprite, \"some\" corner points, or the sprite's \"center\" point.\n    `hitTestTile` arguments:\n    sprite, array, collisionTileGridIdNumber, worldObject, spritesPointsToCheck\n    ```js\n    tu.hitTestTile(sprite, array, collisioGid, world, pointsToCheck);\n    ```\n    The `world` object (the 4th argument) has to have these properties:\n    `tileheight`, `tilewidth`, `widthInTiles`.\n    Here's how you could use  `hitTestTile` to check for a collision between a sprite\n    called `alien` and an array of wall sprites with map gid numbers of 0.\n    ```js\n    let alienVsFloor = g.hitTestTile(alien, wallMapArray, 0, world, \"every\");\n    ```\n    */\n\n  }, {\n    key: \"hitTestTile\",\n    value: function hitTestTile(sprite, mapArray, gidToCheck, world, pointsToCheck) {\n      var _this = this;\n\n      //The `checkPoints` helper function Loop through the sprite's corner points to\n      //find out if they are inside an array cell that you're interested in.\n      //Return `true` if they are\n      var checkPoints = function checkPoints(key) {\n\n        //Get a reference to the current point to check.\n        //(`topLeft`, `topRight`, `bottomLeft` or `bottomRight` )\n        var point = sprite.collisionPoints[key];\n\n        //Find the point's index number in the map array\n        collision.index = _this.getIndex(point.x, point.y, world.tilewidth, world.tileheight, world.widthInTiles);\n\n        //Find out what the gid value is in the map position\n        //that the point is currently over\n        collision.gid = mapArray[collision.index];\n\n        //If it matches the value of the gid that we're interested, in\n        //then there's been a collision\n        if (collision.gid === gidToCheck) {\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      //Assign \"some\" as the default value for `pointsToCheck`\n      pointsToCheck = pointsToCheck || \"some\";\n\n      //The collision object that will be returned by this function\n      var collision = {};\n\n      //Which points do you want to check?\n      //\"every\", \"some\" or \"center\"?\n      switch (pointsToCheck) {\n        case \"center\":\n\n          //`hit` will be true only if the center point is touching\n          var point = {\n            center: {\n              x: sprite.centerX,\n              y: sprite.centerY\n            }\n          };\n          sprite.collisionPoints = point;\n          collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n          break;\n        case \"every\":\n\n          //`hit` will be true if every point is touching\n          sprite.collisionPoints = this.getPoints(sprite);\n          collision.hit = Object.keys(sprite.collisionPoints).every(checkPoints);\n          break;\n        case \"some\":\n\n          //`hit` will be true only if some points are touching\n          sprite.collisionPoints = this.getPoints(sprite);\n          collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n          break;\n      }\n\n      //Return the collision object.\n      //`collision.hit` will be true if a collision is detected.\n      //`collision.index` tells you the map array index number where the\n      //collision occured\n      return collision;\n    }\n\n    //### updateMap\n    /*\n    `updateMap` takes a map array and adds a sprite's grid index number (`gid`) to it. \n    It finds the sprite's new index position, and retuns the new map array.\n    You can use it to do very efficient collision detection in tile based game worlds.\n    `updateMap` arguments:\n    array, singleSpriteOrArrayOfSprites, worldObject\n    The `world` object (the 4th argument) has to have these properties:\n    `tileheight`, `tilewidth`, `widthInTiles`.\n    The sprite objects have to have have these properties:\n    `centerX`, `centerY`, `index`, `gid` (The number in the array that represpents the sprite)\n    Here's an example of how you could use `updateMap` in your game code like this:\n    \n        blockLayer.data = updateMap(blockLayer.data, blockLayer.children, world);\n     The `blockLayer.data` array would now contain the new index position numbers of all the \n    child sprites on that layer.\n    */\n\n  }, {\n    key: \"updateMap\",\n    value: function updateMap(mapArray, spritesToUpdate, world) {\n      var _this2 = this;\n\n      //First create a map a new array filled with zeros.\n      //The new map array will be exactly the same size as the original\n      var newMapArray = mapArray.map(function (gid) {\n        gid = 0;\n        return gid;\n      });\n\n      //Is `spriteToUpdate` an array of sprites?\n      if (spritesToUpdate instanceof Array) {\n        (function () {\n\n          //Get the index number of each sprite in the `spritesToUpdate` array\n          //and add the sprite's `gid` to the matching index on the map\n          var self = _this2;\n          spritesToUpdate.forEach(function (sprite) {\n\n            //Find the new index number\n            sprite.index = self.getIndex(sprite.centerX, sprite.centerY, world.tilewidth, world.tileheight, world.widthInTiles);\n\n            //Add the sprite's `gid` number to the correct index on the map\n            newMapArray[sprite.index] = sprite.gid;\n          });\n        })();\n      }\n\n      //Is `spritesToUpdate` just a single sprite?\n      else {\n          var sprite = spritesToUpdate;\n          //Find the new index number\n          sprite.index = this.getIndex(sprite.centerX, sprite.centerY, world.tilewidth, world.tileheight, world.widthInTiles);\n\n          //Add the sprite's `gid` number to the correct index on the map\n          newMapArray[sprite.index] = sprite.gid;\n        }\n\n      //Return the new map array to replace the previous one\n      return newMapArray;\n    }\n\n    /*\n    ###makeTiledWorld\n     `makeTiledWorld` is a quick and easy way to display a game world designed in\n    Tiled Editor. Supply `makeTiledWorld` with 2 **string arguments**: \n    \n    1. A JSON file generated by Tiled Editor. \n    2. A source image that represents the tile set you used to create the Tiled Editor world.\n    ```js\n    let world = makeTiledWorld(\"tiledEditorMapData.json\", \"tileset.png\");\n    ```\n    (Note: `makeTiledWorld` looks for the JSON data file in Pixi's `loader.resources` object. So, \n    make sure you've loaded the JSON file using Pixi's `loader`.)\n     `makeTiledWorld` will return a Pixi `Container` that contains all the things in your Tiled Editor\n    map as Pixi sprites.\n     All the image tiles you create in Tiled Editor are automatically converted into Pixi sprites\n    for you by `makeTiledWorld`. You can access all of them using two methods: `getObject` (for\n    single sprites) and `getObjects` (with an \"s\") for multiple sprites. Let's find out how they work.\n    \n    ####world.getObject\n     Tile Editor lets you assign a \"name\" properties any object.\n    You can access any sprite by this name using the `getObject` method. `getObject` searches for and\n    returns a sprite in the `world` that has the same `name` property that you assigned\n    in Tiled Editor. Here's how to use `getObject` to look for an object called \"alien\"\n    in the Tiled map data and assign it to a variable called `alien`\n    ```js  \n    let alien = world.getObject(\"alien\");  \n    ```\n    `alien` is now an ordinary Pixi sprite that you can control just like any other Pixi\n    sprite in your games.\n     #### Creating sprites from generic objects\n     Tiled Editor lets you create generic objects. These are objects that don't have images associated\n    with them. Generic objects are handy to use, because they let you create complex game objects inside\n    Tiled Editor, as pure data. You can then use that data your game code to build complex game objects.\n     For example, imagine that you want to create a complex animated walking sprite called \"elf\".\n    First, create the elf object in Tiled Editor as a generic object, but don't assign any image tiles\n    to it. Next, in your game code, create a new Pixi MovieClip called `elf` and give it any textures you want\n    to use for its animation states.\n    ```js\n    //Create a new Pixi MovieClip sprite\n    let elf = new PIXI.MovieClip(elfSpriteTextures);\n    ```\n    Then use the `x` and `y` data from the generic \"elf\" object you created in Tiled Editor to position the \n    `elf` sprite.\n    ```js\n    elf.x = world.getObject(\"elf\").x;\n    elf.y = world.getObject(\"elf\").y;\n    ```\n    This is a simple example, but you could make very complex data objects in Tiled Editor and \n    use them to build complex sprites in the same way.\n     ####Accessing Tiled Editor layer groups \n    \n    Tiled Editor lets you create **layer groups**. Each layer group you create\n    in Tiled Editor is automatically converted by `makeTiledWorld` into a Pixi `Container`\n    object. You can access those containers using `getObject` to extract the layer group\n    container. \n     Here's how you could extract the layer group called \"objects\" and add the \n    `elf` sprite to it.\n    ```js\n    let objectsLayer = world.getObject(\"objects\");\n    objectsLayer.addChild(elf);\n    ```\n    If you want to add the sprite to a different world layer, you can do it like this:\n    ```js\n    world.getObject(\"treeTops\").addChild(elf);\n    ```\n    If you want to access all the sprites in a specific Tiled Editor layer, just supply\n    `getObject` with the name of the layer. For example, if the layer name is \"items\", you\n    can access it like this:\n    ```js\n    let itemsLayer = world.getObject(\"items\");\n    ```\n    `itemsLayer` is now a Pixi container with a `children` array that contains all the sprites\n    on that layer.  \n     To be safe, clone this array to create a new version\n    that doesn't point to the original data file:\n    ```js\n    items = itemsLayer.children.slice(0);  \n    ```\n    You can now manipulate the `items` array freely without worrying about changing\n    the original array. This can possibly help prevent some weird bugs in a complex game.\n     ###Finding the \"gid\" values\n     Tiled Editor uses \"gid\" numbers to identify different kinds of things in the world.\n    If you ever need to extract sprites with specific `gid` numbers in a \n    layer that contains different kinds of things, you can do it like this:\n    ```js\n    let items = itemsLayer.children.map(sprite => {\n      if (sprite.gid !== 0) return sprite; \n    });\n    ```\n    Every sprite created by `makeTiledWorld` has a `gid` property with a value that matches its\n    Tiled Editor \"gid\" value.\n     ####Accessing a layer's \"data\" array\n     Tiled Editor's layers have a `data` property\n    that is an array containing all the grid index numbers (`gid`) of\n    the tiles in that array. Imagine that you've got a layer full of similar\n    tiles representing the walls in a game. How do you access the array\n    containing all the \"gid\" numbers of the wall sprites in that layer? If the layer's name is called \"wallLayer\", you \n    can access the `wallLayer`'s `data` array of sprites like this: \n    ```js\n    wallMapArray = world.getObject(\"wallLayer\").data;\n    ```\n    `wallMapArray` is now an array of \"gid\" numbers referring to all the sprites on that\n    layer. You can now use this data for collision detection, or doing any other kind\n    of world building.\n     ###world.getObjects\n     There's another method called `getObjects` (with an \"s\"!) that lets you extract\n    an array of sprites from the Tiled Editor data. Imagine that you created three\n    game objects in Tiled Editor called \"marmot\", \"skull\" and \"heart\". `makeTiledWorld`\n    automatically turns them into sprites, and you can access\n    all of them as array of sprites using `getObjects` like this:\n    ```js\n    let gameItemsArray = world.getObjects(\"marmot\", \"skull\", \"heart\");\n    ```\n    */\n\n  }, {\n    key: \"makeTiledWorld\",\n    value: function makeTiledWorld(jsonTiledMap, tileset) {\n      var _this3 = this;\n\n      //Create a group called `world` to contain all the layers, sprites\n      //and objects from the `tiledMap`. The `world` object is going to be\n      //returned to the main game program\n      var tiledMap = PIXI.loader.resources[jsonTiledMap].data;\n      var world = new this.Container();\n\n      world.tileheight = tiledMap.tileheight;\n      world.tilewidth = tiledMap.tilewidth;\n\n      //Calculate the `width` and `height` of the world, in pixels\n      world.worldWidth = tiledMap.width * tiledMap.tilewidth;\n      world.worldHeight = tiledMap.height * tiledMap.tileheight;\n\n      //Get a reference to the world's height and width in\n      //tiles, in case you need to know this later (you will!)\n      world.widthInTiles = tiledMap.width;\n      world.heightInTiles = tiledMap.height;\n\n      //Create an `objects` array to store references to any\n      //named objects in the map. Named objects all have\n      //a `name` property that was assigned in Tiled Editor\n      world.objects = [];\n\n      //The optional spacing (padding) around each tile\n      //This is to account for spacing around tiles\n      //that's commonly used with texture atlas tilesets. Set the\n      //`spacing` property when you create a new map in Tiled Editor\n      var spacing = tiledMap.tilesets[0].spacing;\n\n      //Figure out how many columns there are on the tileset.\n      //This is the width of the image, divided by the width\n      //of each tile, plus any optional spacing thats around each tile\n      var numberOfTilesetColumns = Math.floor(tiledMap.tilesets[0].imagewidth / (tiledMap.tilewidth + spacing));\n\n      //Loop through all the map layers\n      tiledMap.layers.forEach(function (tiledLayer) {\n\n        //Make a group for this layer and copy\n        //all of the layer properties onto it.\n        var layerGroup = new _this3.Container();\n\n        Object.keys(tiledLayer).forEach(function (key) {\n          //Add all the layer's properties to the group, except the\n          //width and height (because the group will work those our for\n          //itself based on its content).\n          if (key !== \"width\" && key !== \"height\") {\n            layerGroup[key] = tiledLayer[key];\n          }\n        });\n\n        //Set the width and height of the layer to\n        //the `world`'s width and height\n        //layerGroup.width = world.width;\n        //layerGroup.height = world.height;\n\n        //Translate `opacity` to `alpha`\n        layerGroup.alpha = tiledLayer.opacity;\n\n        //Add the group to the `world`\n        world.addChild(layerGroup);\n\n        //Push the group into the world's `objects` array\n        //So you can access it later\n        world.objects.push(layerGroup);\n\n        //Is this current layer a `tilelayer`?\n        if (tiledLayer.type === \"tilelayer\") {\n\n          //Loop through the `data` array of this layer\n          tiledLayer.data.forEach(function (gid, index) {\n            var tileSprite = undefined,\n                texture = undefined,\n                mapX = undefined,\n                mapY = undefined,\n                tilesetX = undefined,\n                tilesetY = undefined,\n                mapColumn = undefined,\n                mapRow = undefined,\n                tilesetColumn = undefined,\n                tilesetRow = undefined;\n\n            //If the grid id number (`gid`) isn't zero, create a sprite\n            if (gid !== 0) {\n              (function () {\n\n                //Figure out the map column and row number that we're on, and then\n                //calculate the grid cell's x and y pixel position.\n                mapColumn = index % world.widthInTiles;\n                mapRow = Math.floor(index / world.widthInTiles);\n                mapX = mapColumn * world.tilewidth;\n                mapY = mapRow * world.tileheight;\n\n                //Figure out the column and row number that the tileset\n                //image is on, and then use those values to calculate\n                //the x and y pixel position of the image on the tileset\n                tilesetColumn = (gid - 1) % numberOfTilesetColumns;\n                tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);\n                tilesetX = tilesetColumn * world.tilewidth;\n                tilesetY = tilesetRow * world.tileheight;\n\n                //Compensate for any optional spacing (padding) around the tiles if\n                //there is any. This bit of code accumlates the spacing offsets from the\n                //left side of the tileset and adds them to the current tile's position\n                if (spacing > 0) {\n                  tilesetX += spacing + spacing * ((gid - 1) % numberOfTilesetColumns);\n                  tilesetY += spacing + spacing * Math.floor((gid - 1) / numberOfTilesetColumns);\n                }\n\n                //Use the above values to create the sprite's image from\n                //the tileset image\n                texture = _this3.frame(tileset, tilesetX, tilesetY, world.tilewidth, world.tileheight);\n\n                //I've dedcided that any tiles that have a `name` property are important\n                //and should be accessible in the `world.objects` array.\n\n                var tileproperties = tiledMap.tilesets[0].tileproperties,\n                    key = String(gid - 1);\n\n                //If the JSON `tileproperties` object has a sub-object that\n                //matches the current tile, and that sub-object has a `name` property,\n                //then create a sprite and assign the tile properties onto\n                //the sprite\n                if (tileproperties[key] && tileproperties[key].name) {\n\n                  //Make a sprite\n                  tileSprite = new _this3.Sprite(texture);\n\n                  //Copy all of the tile's properties onto the sprite\n                  //(This includes the `name` property)\n                  Object.keys(tileproperties[key]).forEach(function (property) {\n\n                    //console.log(tileproperties[key][property])\n                    tileSprite[property] = tileproperties[key][property];\n                  });\n\n                  //Push the sprite into the world's `objects` array\n                  //so that you can access it by `name` later\n                  world.objects.push(tileSprite);\n                }\n\n                //If the tile doesn't have a `name` property, just use it to\n                //create an ordinary sprite (it will only need one texture)\n                else {\n                    tileSprite = new _this3.Sprite(texture);\n                  }\n\n                //Position the sprite on the map\n                tileSprite.x = mapX;\n                tileSprite.y = mapY;\n\n                //Make a record of the sprite's index number in the array\n                //(We'll use this for collision detection later)\n                tileSprite.index = index;\n\n                //Make a record of the sprite's `gid` on the tileset.\n                //This will also be useful for collision detection later\n                tileSprite.gid = gid;\n\n                //Add the sprite to the current layer group\n                layerGroup.addChild(tileSprite);\n              })();\n            }\n          });\n        }\n\n        //Is this layer an `objectgroup`?\n        if (tiledLayer.type === \"objectgroup\") {\n          tiledLayer.objects.forEach(function (object) {\n\n            //We're just going to capture the object's properties\n            //so that we can decide what to do with it later\n\n            //Get a reference to the layer group the object is in\n            object.group = layerGroup;\n\n            //Because this is an object layer, it doesn't contain any\n            //sprites, just data object. That means it won't be able to\n            //calucalte its own height and width. To help it out, give\n            //the `layerGroup` the same `width` and `height` as the `world`\n            //layerGroup.width = world.width;\n            //layerGroup.height = world.height;\n\n            //Push the object into the world's `objects` array\n            world.objects.push(object);\n          });\n        }\n      });\n\n      //Search functions\n      //`world.getObject` and `world.getObjects`  search for and return\n      //any sprites or objects in the `world.objects` array.\n      //Any object that has a `name` propery in\n      //Tiled Editor will show up in a search.\n      //`getObject` gives you a single object, `getObjects` gives you an array\n      //of objects.\n      //`getObject` returns the actual search function, so you\n      //can use the following format to directly access a single object:\n      //sprite.x = world.getObject(\"anySprite\").x;\n      //sprite.y = world.getObject(\"anySprite\").y;\n\n      world.getObject = function (objectName) {\n        var searchForObject = function searchForObject() {\n          var foundObject = undefined;\n          world.objects.some(function (object) {\n            if (object.name && object.name === objectName) {\n              foundObject = object;\n              return true;\n            }\n          });\n          if (foundObject) {\n            return foundObject;\n          } else {\n            throw new Error(\"There is no object with the property name: \" + objectName);\n          }\n        };\n\n        //Return the search function\n        return searchForObject();\n      };\n\n      world.getObjects = function (objectNames) {\n        var foundObjects = [];\n        world.objects.forEach(function (object) {\n          if (object.name && objectNames.indexOf(object.name) !== -1) {\n            foundObjects.push(object);\n          }\n        });\n        if (foundObjects.length > 0) {\n          return foundObjects;\n        } else {\n          throw new Error(\"I could not find those objects\");\n        }\n        return foundObjects;\n      };\n\n      //That's it, we're done!\n      //Finally, return the `world` object back to the game program\n      return world;\n    }\n\n    /* Isometric tile utilities */\n\n    /*\n    ### byDepth\n    And array `sort` function that depth-sorts sprites according to\n    their `z` properties\n    */\n\n  }, {\n    key: \"byDepth\",\n    value: function byDepth(a, b) {\n      //Calculate the depths of `a` and `b`\n      //(add `1` to `a.z` and `b.x` to avoid multiplying by 0)\n      a.depth = (a.cartX + a.cartY) * (a.z + 1);\n      b.depth = (b.cartX + b.cartY) * (b.z + 1);\n\n      //Move sprites with a lower depth to a higher position in the array\n      if (a.depth < b.depth) {\n        return -1;\n      } else if (a.depth > b.depth) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    /*\n    ### hitTestIsoTile\n    Same API as `hitTestTile`, except that it works with isometric sprites.\n    Make sure that your `world` object has properties called\n    `cartTileWidth` and `cartTileHeight` that define the Cartesian with and \n    height of your tile cells, in pixels.\n     */\n\n  }, {\n    key: \"hitTestIsoTile\",\n    value: function hitTestIsoTile(sprite, mapArray, gidToCheck, world, pointsToCheck) {\n      var _this4 = this;\n\n      //The `checkPoints` helper function Loop through the sprite's corner points to\n      //find out if they are inside an array cell that you're interested in.\n      //Return `true` if they are\n      var checkPoints = function checkPoints(key) {\n\n        //Get a reference to the current point to check.\n        //(`topLeft`, `topRight`, `bottomLeft` or `bottomRight` )\n        var point = sprite.collisionPoints[key];\n\n        //Find the point's index number in the map array\n        collision.index = _this4.getIndex(point.x, point.y, world.cartTilewidth, world.cartTileheight, world.widthInTiles);\n\n        //Find out what the gid value is in the map position\n        //that the point is currently over\n        collision.gid = mapArray[collision.index];\n\n        //If it matches the value of the gid that we're interested, in\n        //then there's been a collision\n        if (collision.gid === gidToCheck) {\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      //Assign \"some\" as the default value for `pointsToCheck`\n      pointsToCheck = pointsToCheck || \"some\";\n\n      //The collision object that will be returned by this function\n      var collision = {};\n\n      //Which points do you want to check?\n      //\"every\", \"some\" or \"center\"?\n      switch (pointsToCheck) {\n        case \"center\":\n\n          //`hit` will be true only if the center point is touching\n          var point = {\n            center: {\n              //x: sprite.centerX,\n              //y: sprite.centerY\n              x: s.cartX + ca.x + ca.width / 2,\n              y: s.cartY + ca.y + ca.height / 2\n            }\n          };\n          sprite.collisionPoints = point;\n          collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n          break;\n        case \"every\":\n\n          //`hit` will be true if every point is touching\n          sprite.collisionPoints = this.getIsoPoints(sprite);\n          collision.hit = Object.keys(sprite.collisionPoints).every(checkPoints);\n          break;\n        case \"some\":\n\n          //`hit` will be true only if some points are touching\n          sprite.collisionPoints = this.getIsoPoints(sprite);\n          collision.hit = Object.keys(sprite.collisionPoints).some(checkPoints);\n          break;\n      }\n\n      //Return the collision object.\n      //`collision.hit` will be true if a collision is detected.\n      //`collision.index` tells you the map array index number where the\n      //collision occured\n      return collision;\n    }\n\n    /*\n    ### getIsoPoints\n    The isomertic version of `getPoints`\n    */\n\n  }, {\n    key: \"getIsoPoints\",\n    value: function getIsoPoints(s) {\n      var ca = s.collisionArea;\n      if (ca !== undefined) {\n        return {\n          topLeft: {\n            x: s.cartX + ca.x,\n            y: s.cartY + ca.y\n          },\n          topRight: {\n            x: s.cartX + ca.x + ca.width,\n            y: s.cartY + ca.y\n          },\n          bottomLeft: {\n            x: s.cartX + ca.x,\n            y: s.cartY + ca.y + ca.height\n          },\n          bottomRight: {\n            x: s.cartX + ca.x + ca.width,\n            y: s.cartY + ca.y + ca.height\n          }\n        };\n      } else {\n        return {\n          topLeft: {\n            x: s.cartX,\n            y: s.cartY\n          },\n          topRight: {\n            x: s.cartX + s.cartWidth - 1,\n            y: s.cartY\n          },\n          bottomLeft: {\n            x: s.cartX,\n            y: s.cartY + s.cartHeight - 1\n          },\n          bottomRight: {\n            x: s.cartX + s.cartWidth - 1,\n            y: s.cartY + s.cartHeight - 1\n          }\n        };\n      }\n    }\n\n    /*\n    ### makeIsoPointer\n    Used to add a isometric properties to any mouse/touch `pointer` object with \n    `x` and `y` properties. Supply `makeIsoPointer` with the pointer object and\n    the isometric `world` object \n    */\n\n    //Create some useful properties on the pointer\n\n  }, {\n    key: \"makeIsoPointer\",\n    value: function makeIsoPointer(pointer, world) {\n      Object.defineProperties(pointer, {\n\n        //The isometric's world's Cartesian coordiantes\n        cartX: {\n          get: function get() {\n            var x = (2 * this.y + this.x - (2 * world.y + world.x)) / 2 - world.cartTilewidth / 2;\n\n            return x;\n          },\n\n          enumerable: true,\n          configurable: true\n        },\n        cartY: {\n          get: function get() {\n            var y = (2 * this.y - this.x - (2 * world.y - world.x)) / 2 + world.cartTileheight / 2;\n\n            return y;\n          },\n\n          enumerable: true,\n          configurable: true\n        },\n\n        //The tile's column and row in the array\n        column: {\n          get: function get() {\n            return Math.floor(this.cartX / world.cartTilewidth);\n          },\n\n          enumerable: true,\n          configurable: true\n        },\n        row: {\n          get: function get() {\n            return Math.floor(this.cartY / world.cartTileheight);\n          },\n\n          enumerable: true,\n          configurable: true\n        },\n\n        //The tile's index number in the array\n        index: {\n          get: function get() {\n            var index = {};\n\n            //Convert pixel coordinates to map index coordinates\n            index.x = Math.floor(this.cartX / world.cartTilewidth);\n            index.y = Math.floor(this.cartY / world.cartTileheight);\n\n            //Return the index number\n            return index.x + index.y * world.widthInTiles;\n          },\n\n          enumerable: true,\n          configurable: true\n        }\n      });\n    }\n\n    /*\n    ### isoRectangle\n    A function for creating a simple isometric diamond\n    shaped rectangle using Pixi's graphics library\n    */\n\n  }, {\n    key: \"isoRectangle\",\n    value: function isoRectangle(width, height, fillStyle) {\n\n      //Figure out the `halfHeight` value\n      var halfHeight = height / 2;\n\n      //Draw the flattened and rotated square (diamond shape)\n      var rectangle = new this.Graphics();\n      rectangle.beginFill(fillStyle);\n      rectangle.moveTo(0, 0);\n      rectangle.lineTo(width, halfHeight);\n      rectangle.lineTo(0, height);\n      rectangle.lineTo(-width, halfHeight);\n      rectangle.lineTo(0, 0);\n      rectangle.endFill();\n\n      //Generate a texture from the rectangle\n      var texture = rectangle.generateTexture();\n\n      //Use the texture to create a sprite\n      var sprite = new this.Sprite(texture);\n\n      //Return it to the main program\n      return sprite;\n    }\n\n    /*\n    ### addIsoProperties\n    Add properties to a sprite to help work between Cartesian\n    and isometric properties: `isoX`, `isoY`, `cartX`, \n    `cartWidth` and `cartHeight`.\n    */\n\n  }, {\n    key: \"addIsoProperties\",\n    value: function addIsoProperties(sprite, x, y, width, height) {\n\n      //Cartisian (flat 2D) properties\n      sprite.cartX = x;\n      sprite.cartY = y;\n      sprite.cartWidth = width;\n      sprite.cartHeight = height;\n\n      //Add a getter/setter for the isometric properties\n      Object.defineProperties(sprite, {\n        isoX: {\n          get: function get() {\n            return this.cartX - this.cartY;\n          },\n\n          enumerable: true,\n          configurable: true\n        },\n        isoY: {\n          get: function get() {\n            return (this.cartX + this.cartY) / 2;\n          },\n\n          enumerable: true,\n          configurable: true\n        }\n      });\n    }\n\n    /*\n    ### makeIsoTiledWorld\n    Make an isometric world from TiledEditor map data. Uses the same API as `makeTiledWorld`\n     */\n\n  }, {\n    key: \"makeIsoTiledWorld\",\n    value: function makeIsoTiledWorld(jsonTiledMap, tileset) {\n      var _this5 = this;\n\n      //Create a group called `world` to contain all the layers, sprites\n      //and objects from the `tiledMap`. The `world` object is going to be\n      //returned to the main game program\n      var tiledMap = PIXI.loader.resources[jsonTiledMap].data;\n\n      //A. You need to add three custom properties to your Tiled Editor\n      //map: `cartTilewidth`,`cartTileheight` and `tileDepth`. They define the Cartesian\n      //dimesions of the tiles (32x32x64).\n      //Check to make sure that these custom properties exist \n      if (!tiledMap.properties.cartTilewidth && !tiledMap.properties.cartTileheight && !tiledMao.properties.tileDepth) {\n        throw new Error(\"Set custom cartTilewidth, cartTileheight and tileDepth map properties in Tiled Editor\");\n      }\n\n      //Create the `world` container\n      var world = new this.Container();\n\n      //B. Set the `tileHeight` to the `tiledMap`'s `tileDepth` property\n      //so that it matches the pixel height of the sprite tile image\n      world.tileheight = parseInt(tiledMap.properties.tileDepth);\n      world.tilewidth = tiledMap.tilewidth;\n\n      //C. Define the Cartesian dimesions of each tile\n      world.cartTileheight = parseInt(tiledMap.properties.cartTileheight);\n      world.cartTilewidth = parseInt(tiledMap.properties.cartTilewidth);\n\n      //D. Calculate the `width` and `height` of the world, in pixels\n      //using the `world.cartTileHeight` and `world.cartTilewidth`\n      //values\n      world.worldWidth = tiledMap.width * world.cartTilewidth;\n      world.worldHeight = tiledMap.height * world.cartTileheight;\n\n      //Get a reference to the world's height and width in\n      //tiles, in case you need to know this later (you will!)\n      world.widthInTiles = tiledMap.width;\n      world.heightInTiles = tiledMap.height;\n\n      //Create an `objects` array to store references to any\n      //named objects in the map. Named objects all have\n      //a `name` property that was assigned in Tiled Editor\n      world.objects = [];\n\n      //The optional spacing (padding) around each tile\n      //This is to account for spacing around tiles\n      //that's commonly used with texture atlas tilesets. Set the\n      //`spacing` property when you create a new map in Tiled Editor\n      var spacing = tiledMap.tilesets[0].spacing;\n\n      //Figure out how many columns there are on the tileset.\n      //This is the width of the image, divided by the width\n      //of each tile, plus any optional spacing thats around each tile\n      var numberOfTilesetColumns = Math.floor(tiledMap.tilesets[0].imagewidth / (tiledMap.tilewidth + spacing));\n\n      //E. A `z` property to help track which depth level the sprites are on\n      var z = 0;\n\n      //Loop through all the map layers\n      tiledMap.layers.forEach(function (tiledLayer) {\n\n        //Make a group for this layer and copy\n        //all of the layer properties onto it.\n        var layerGroup = new _this5.Container();\n\n        Object.keys(tiledLayer).forEach(function (key) {\n          //Add all the layer's properties to the group, except the\n          //width and height (because the group will work those our for\n          //itself based on its content).\n          if (key !== \"width\" && key !== \"height\") {\n            layerGroup[key] = tiledLayer[key];\n          }\n        });\n\n        //Translate `opacity` to `alpha`\n        layerGroup.alpha = tiledLayer.opacity;\n\n        //Add the group to the `world`\n        world.addChild(layerGroup);\n\n        //Push the group into the world's `objects` array\n        //So you can access it later\n        world.objects.push(layerGroup);\n\n        //Is this current layer a `tilelayer`?\n        if (tiledLayer.type === \"tilelayer\") {\n\n          //Loop through the `data` array of this layer\n          tiledLayer.data.forEach(function (gid, index) {\n            var tileSprite = undefined,\n                texture = undefined,\n                mapX = undefined,\n                mapY = undefined,\n                tilesetX = undefined,\n                tilesetY = undefined,\n                mapColumn = undefined,\n                mapRow = undefined,\n                tilesetColumn = undefined,\n                tilesetRow = undefined;\n\n            //If the grid id number (`gid`) isn't zero, create a sprite\n            if (gid !== 0) {\n              (function () {\n\n                //Figure out the map column and row number that we're on, and then\n                //calculate the grid cell's x and y pixel position.\n                mapColumn = index % world.widthInTiles;\n                mapRow = Math.floor(index / world.widthInTiles);\n\n                //F. Use the Cartesian values to find the\n                //`mapX` and `mapY` values\n                mapX = mapColumn * world.cartTilewidth;\n                mapY = mapRow * world.cartTileheight;\n\n                //Figure out the column and row number that the tileset\n                //image is on, and then use those values to calculate\n                //the x and y pixel position of the image on the tileset\n                tilesetColumn = (gid - 1) % numberOfTilesetColumns;\n                tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);\n                tilesetX = tilesetColumn * world.tilewidth;\n                tilesetY = tilesetRow * world.tileheight;\n\n                //Compensate for any optional spacing (padding) around the tiles if\n                //there is any. This bit of code accumlates the spacing offsets from the\n                //left side of the tileset and adds them to the current tile's position\n                if (spacing > 0) {\n                  tilesetX += spacing + spacing * ((gid - 1) % numberOfTilesetColumns);\n                  tilesetY += spacing + spacing * Math.floor((gid - 1) / numberOfTilesetColumns);\n                }\n\n                //Use the above values to create the sprite's image from\n                //the tileset image\n                texture = _this5.frame(tileset, tilesetX, tilesetY, world.tilewidth, world.tileheight);\n\n                //I've dedcided that any tiles that have a `name` property are important\n                //and should be accessible in the `world.objects` array.\n\n                var tileproperties = tiledMap.tilesets[0].tileproperties,\n                    key = String(gid - 1);\n\n                //If the JSON `tileproperties` object has a sub-object that\n                //matches the current tile, and that sub-object has a `name` property,\n                //then create a sprite and assign the tile properties onto\n                //the sprite\n                if (tileproperties[key] && tileproperties[key].name) {\n\n                  //Make a sprite\n                  tileSprite = new _this5.Sprite(texture);\n\n                  //Copy all of the tile's properties onto the sprite\n                  //(This includes the `name` property)\n                  Object.keys(tileproperties[key]).forEach(function (property) {\n\n                    //console.log(tileproperties[key][property])\n                    tileSprite[property] = tileproperties[key][property];\n                  });\n\n                  //Push the sprite into the world's `objects` array\n                  //so that you can access it by `name` later\n                  world.objects.push(tileSprite);\n                }\n\n                //If the tile doesn't have a `name` property, just use it to\n                //create an ordinary sprite (it will only need one texture)\n                else {\n                    tileSprite = new _this5.Sprite(texture);\n                  }\n\n                //G. Add isometric properties to the sprite\n                _this5.addIsoProperties(tileSprite, mapX, mapY, world.cartTilewidth, world.cartTileheight);\n\n                //H. Use the isometric position to add the sprite to the world\n                tileSprite.x = tileSprite.isoX;\n                tileSprite.y = tileSprite.isoY;\n                tileSprite.z = z;\n\n                //Make a record of the sprite's index number in the array\n                //(We'll use this for collision detection later)\n                tileSprite.index = index;\n\n                //Make a record of the sprite's `gid` on the tileset.\n                //This will also be useful for collision detection later\n                tileSprite.gid = gid;\n\n                //Add the sprite to the current layer group\n                layerGroup.addChild(tileSprite);\n              })();\n            }\n          });\n        }\n\n        //Is this layer an `objectgroup`?\n        if (tiledLayer.type === \"objectgroup\") {\n          tiledLayer.objects.forEach(function (object) {\n\n            //We're just going to capture the object's properties\n            //so that we can decide what to do with it later\n\n            //Get a reference to the layer group the object is in\n            object.group = layerGroup;\n\n            //Push the object into the world's `objects` array\n            world.objects.push(object);\n          });\n        }\n\n        //I. Add 1 to the z index (the first layer will have a z index of `1`)\n        z += 1;\n      });\n\n      //Search functions\n      //`world.getObject` and `world.getObjects`  search for and return\n      //any sprites or objects in the `world.objects` array.\n      //Any object that has a `name` propery in\n      //Tiled Editor will show up in a search.\n      //`getObject` gives you a single object, `getObjects` gives you an array\n      //of objects.\n      //`getObject` returns the actual search function, so you\n      //can use the following format to directly access a single object:\n      //sprite.x = world.getObject(\"anySprite\").x;\n      //sprite.y = world.getObject(\"anySprite\").y;\n\n      world.getObject = function (objectName) {\n        var searchForObject = function searchForObject() {\n          var foundObject = undefined;\n          world.objects.some(function (object) {\n            if (object.name && object.name === objectName) {\n              foundObject = object;\n              return true;\n            }\n          });\n          if (foundObject) {\n            return foundObject;\n          } else {\n            throw new Error(\"There is no object with the property name: \" + objectName);\n          }\n        };\n\n        //Return the search function\n        return searchForObject();\n      };\n\n      world.getObjects = function (objectNames) {\n        var foundObjects = [];\n        world.objects.forEach(function (object) {\n          if (object.name && objectNames.indexOf(object.name) !== -1) {\n            foundObjects.push(object);\n          }\n        });\n        if (foundObjects.length > 0) {\n          return foundObjects;\n        } else {\n          throw new Error(\"I could not find those objects\");\n        }\n        return foundObjects;\n      };\n\n      //That's it, we're done!\n      //Finally, return the `world` object back to the game program\n      return world;\n    }\n  }]);\n\n  return TileUtilities;\n})();\n//# sourceMappingURL=tileUtilities.js.map"]}